<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | hrchen's blogging]]></title>
  <link href="http://hrchen.com/category/ios/atom.xml" rel="self"/>
  <link href="http://hrchen.com/"/>
  <updated>2013-06-30T04:09:40+08:00</updated>
  <id>http://hrchen.com/</id>
  <author>
    <name><![CDATA[hrchen]]></name>
    <email><![CDATA[dr.hrchen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程Part 2/3 - NSOperation]]></title>
    <link href="http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-2/"/>
    <updated>2013-06-28T23:59:00+08:00</updated>
    <id>http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-2</id>
    <content type="html"><![CDATA[<p>多线程编程Part 1介绍了NSThread以及NSRunLoop，这篇Blog介绍另一种并发编程技术：NSOPeration。</p>

<h3>NSOperation &amp; NSOperationQueue</h3>

<p>从头文件NSOperation.h来看接口是非常的简洁，NSOperation本身是一个抽象类，定义了一个要执行的工作，NSOperationQueue是一个工作队列，当工作加入到队列后，NSOperationQueue会自动按照优先顺序及工作的从属依赖关系(如果有的话)组织执行。</p>

<p>NSOperation是没法直接使用的，它只是提供了一个工作的基本逻辑，具体实现还是需要你通过定义自己的NSOperation子类来获得。如果有必要也可以不将NSOperation加入到一个NSOperationQueue中去执行，直接调用起<code>-start</code>也可以直接执行。</p>

<!--more-->


<p>在继承NSOpertaion后，对于非并发的工作，只需要实现NSOperation子类的main方法：</p>

<p>```
-(void)main
{
   @try
   {</p>

<pre><code>  // 处理工作任务
</code></pre>

<p>   }
   @catch(...)
   {</p>

<pre><code>  // 处理异常，但是不能再重新抛出异常
</code></pre>

<p>   }
}
<code>``
由于NSOperation的工作是可以取消Cancel的，那么你在main方法处理工作时就需要不断轮询</code>[self isCancelled]`确认当前的工作是否被取消了。</p>

<p>如果要支持并发工作，那么NSOperation子类需要至少override这四个方法:</p>

<ul>
<li>start</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
</ul>


<p>实现了一个基于Operation的下载器，在Sample Code中可以下载。</p>

<p>```
- (void)operationDidStart
{</p>

<pre><code>[self.lock lock];
NSMutableURLRequest* request = [[NSMutableURLRequest alloc] initWithURL:self.URL
                                                            cachePolicy:NSURLRequestReloadIgnoringCacheData
                                                        timeoutInterval:self.timeoutInterval];
[request setHTTPMethod: @"GET"];

self.connection =[[NSURLConnection alloc] initWithRequest:request
                                                 delegate:self
                                         startImmediately:NO];
[self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
[self.connection start];
[self.lock unlock];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)operationDidFinish
{
  [self.lock lock];
  [self willChangeValueForKey:@"isFinished"];
  [self willChangeValueForKey:@"isExecuting"];</p>

<p>  self.executing = NO;
  self.finished = YES;</p>

<p>  [self didChangeValueForKey:@"isExecuting"];
  [self didChangeValueForKey:@"isFinished"];
  [self.lock unlock];
}</p></li>
<li><p>(void)start
{
  [self.lock lock];
  if ([self isCancelled])
  {
      [self willChangeValueForKey:@"isFinished"];
      self.finished = YES;
      [self didChangeValueForKey:@"isFinished"];
      return;
  }</p>

<p>  [self willChangeValueForKey:@"isExecuting"];
  [self performSelector:@selector(operationDidStart) onThread:[[self class] networkThread] withObject:nil waitUntilDone:NO];
  self.executing = YES;
  [self didChangeValueForKey:@"isExecuting"];
  [self.lock unlock];
}</p></li>
<li><p>(void)cancel
{
  [self.lock lock];
  [super cancel];
  if (self.connection)
  {
      [self.connection cancel];
      self.connection = nil;
  }</p>

<p>  [self.lock unlock];
}</p></li>
<li><p>(BOOL)isConcurrent {
  return YES;
}</p></li>
<li><p>(BOOL)isExecuting {
  return self.executing;
}</p></li>
<li><p>(BOOL)isFinished {
  return self.finished;
}</p></li>
</ul>


<p>```</p>

<p>start方法是工作的入口，通常是你用来设置线程或者其他执行工作任务需要的运行环境的，注意不要调用[super start]；isConcurrent是标识这个Operation是否是并发执行的；isExecuting和isFinished是用来报告当前的工作执行状态情况的，注意必须是线程访问安全的。</p>

<p>注意你的实现要发出合适的KVO通知，因为如果你的NSOperation实现需要用到工作依赖从属特性，而你的实现里没有发出合适的“isFinished”KVO通知，依赖你的NSOperation就无法正常执行。NSOperation有许多支持KVO的属性：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<p>当然也不是说所有的KVO通知都需要自己去实现，例如通常你用不到addObserver到你工作的“isCancelled”属性，你只需要直接调用cancel方法就可以取消这个工作任务。</p>

<p>实现NSOperation子类后，可以直接调用start或者添加到一个NSOperationQueue里：</p>

<p>```
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperation:downloader];</p>

<p>```</p>

<h3>NSOperation和NSOperationQueue其他特性</h3>

<p>工作是有优先级的，可以通过NSOperation的一下两个接口读取或者设置：</p>

<p><code>
- (NSOperationQueuePriority)queuePriority;
- (void)setQueuePriority:(NSOperationQueuePriority)p;
</code></p>

<p>工作之间也可有从属依赖关系，只有依赖的工作完成后才会执行：</p>

<p><code>
- (void)addDependency:(NSOperation *)op;
- (void)removeDependency:(NSOperation *)op;
</code></p>

<p>还可以通过下面接口设置运行NSOpration的子线程优先级：</p>

<p><code>
- (void)setQueuePriority:(NSOperationQueuePriority)priority;
</code></p>

<p>iOS4之后还可以往NSOperation上添加一个结束block，用于在工作执行结束之后的操作：</p>

<p><code>
- (void)setCompletionBlock:(void (^)(void))block;
</code></p>

<p>如果需要阻塞等待NSOperation工作结束(别在主线程这么干)，可以使用接口：</p>

<p><code>
- (void)waitUntilFinished;
</code></p>

<p>NSOperationQueue除了添加NSOperation外，也支持直接添加一个Block(iOS4之后)：</p>

<p><code>
- (void)addOperationWithBlock:(void (^)(void))block
</code></p>

<p>NSOperationQueue可以取消所有添加的工作：</p>

<p><code>
- (void)cancelAllOperations;
</code>
也可以阻塞式的等待所有工作结束(别在主线程这么干)：</p>

<p><code>
- (void)waitUntilAllOperationsAreFinished;
</code></p>

<p>在NSOperation对象中获得被添加的NSOperationQueue队列：</p>

<p><code>
+ (id)currentQueue
</code></p>

<p>要获得一个绑定在主线程的NSOperationQueue队列：</p>

<p><code>
+ (id)mainQueue
</code></p>

<h3>NSInvocationOperation &amp; NSBlockOperation</h3>

<p>其实除非必要，简单的工作完全可以使用官方提供的NSOperation两个子类NSInvocationOperation和NSBlockOperation来实现。</p>

<p>NSInvocationOperation：</p>

<p>```
NSInvocationOperation* theOp = [[NSInvocationOperation alloc]</p>

<pre><code>                   initWithTarget:self                 
                      selector:@selector(myTaskMethod:)                                           
                        object:data];
</code></pre>

<p>```</p>

<p>NSBlockOperation:</p>

<p>```
NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{</p>

<pre><code>  NSLog(@"Beginning operation.\n");
  // Do some work.
</code></pre>

<p>   }];
```</p>

<p>接口非常简单，一看便会。</p>

<h3>Sample Code</h3>

<p>本文例子放在<a href="https://github.com/hrchen/ExamplesForBlog">Github</a>上（工程NSURLConnectionExample中的PTOperationDownloader）。</p>

<h3>参考资料</h3>

<p><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html">Concurrency Programming Guide</a></p>

<p><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html">NSOperation Class Reference</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程Part 2/3 - NSOperation]]></title>
    <link href="http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-2/"/>
    <updated>2013-06-28T23:59:00+08:00</updated>
    <id>http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-2</id>
    <content type="html"><![CDATA[<p>多线程编程Part 1介绍了NSThread以及NSRunLoop，这篇Blog介绍另一种并发编程技术：NSOPeration。</p>

<h3>NSOperation &amp; NSOperationQueue</h3>

<p>从头文件NSOperation.h来看接口是非常的简洁，NSOperation本身是一个抽象类，定义了一个要执行的工作，NSOperationQueue是一个工作队列，当工作加入到队列后，NSOperationQueue会自动按照优先顺序及工作的从属依赖关系(如果有的话)组织执行。</p>

<p>NSOperation是没法直接使用的，它只是提供了一个工作的基本逻辑，具体实现还是需要你通过定义自己的NSOperation子类来获得。如果有必要也可以不将NSOperation加入到一个NSOperationQueue中去执行，直接调用起<code>-start</code>也可以直接执行。</p>

<!--more-->


<p>在继承NSOpertaion后，对于非并发的工作，只需要实现NSOperation子类的main方法：</p>

<p>```
-(void)main
{
   @try
   {</p>

<pre><code>  // 处理工作任务
</code></pre>

<p>   }
   @catch(...)
   {</p>

<pre><code>  // 处理异常，但是不能再重新抛出异常
</code></pre>

<p>   }
}
<code>``
由于NSOperation的工作是可以取消Cancel的，那么你在main方法处理工作时就需要不断轮询</code>[self isCancelled]`确认当前的工作是否被取消了。</p>

<p>如果要支持并发工作，那么NSOperation子类需要至少override这四个方法:</p>

<ul>
<li>start</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
</ul>


<p>实现了一个基于Operation的下载器，在Sample Code中可以下载。</p>

<p>```
- (void)operationDidStart
{</p>

<pre><code>[self.lock lock];
NSMutableURLRequest* request = [[NSMutableURLRequest alloc] initWithURL:self.URL
                                                            cachePolicy:NSURLRequestReloadIgnoringCacheData
                                                        timeoutInterval:self.timeoutInterval];
[request setHTTPMethod: @"GET"];

self.connection =[[NSURLConnection alloc] initWithRequest:request
                                                 delegate:self
                                         startImmediately:NO];
[self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
[self.connection start];
[self.lock unlock];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)operationDidFinish
{
  [self.lock lock];
  [self willChangeValueForKey:@"isFinished"];
  [self willChangeValueForKey:@"isExecuting"];</p>

<p>  self.executing = NO;
  self.finished = YES;</p>

<p>  [self didChangeValueForKey:@"isExecuting"];
  [self didChangeValueForKey:@"isFinished"];
  [self.lock unlock];
}</p></li>
<li><p>(void)start
{
  [self.lock lock];
  if ([self isCancelled])
  {
      [self willChangeValueForKey:@"isFinished"];
      self.finished = YES;
      [self didChangeValueForKey:@"isFinished"];
      return;
  }</p>

<p>  [self willChangeValueForKey:@"isExecuting"];
  [self performSelector:@selector(operationDidStart) onThread:[[self class] networkThread] withObject:nil waitUntilDone:NO];
  self.executing = YES;
  [self didChangeValueForKey:@"isExecuting"];
  [self.lock unlock];
}</p></li>
<li><p>(void)cancel
{
  [self.lock lock];
  [super cancel];
  if (self.connection)
  {
      [self.connection cancel];
      self.connection = nil;
  }</p>

<p>  [self.lock unlock];
}</p></li>
<li><p>(BOOL)isConcurrent {
  return YES;
}</p></li>
<li><p>(BOOL)isExecuting {
  return self.executing;
}</p></li>
<li><p>(BOOL)isFinished {
  return self.finished;
}</p></li>
</ul>


<p>```</p>

<p>start方法是工作的入口，通常是你用来设置线程或者其他执行工作任务需要的运行环境的，注意不要调用[super start]；isConcurrent是标识这个Operation是否是并发执行的；isExecuting和isFinished是用来报告当前的工作执行状态情况的，注意必须是线程访问安全的。</p>

<p>注意你的实现要发出合适的KVO通知，因为如果你的NSOperation实现需要用到工作依赖从属特性，而你的实现里没有发出合适的“isFinished”KVO通知，依赖你的NSOperation就无法正常执行。NSOperation有许多支持KVO的属性：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<p>当然也不是说所有的KVO通知都需要自己去实现，例如通常你用不到addObserver到你工作的“isCancelled”属性，你只需要直接调用cancel方法就可以取消这个工作任务。</p>

<p>实现NSOperation子类后，可以直接调用start或者添加到一个NSOperationQueue里：</p>

<p>```
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperation:downloader];</p>

<p>```</p>

<h3>NSOperation和NSOperationQueue其他特性</h3>

<p>工作是有优先级的，可以通过NSOperation的一下两个接口读取或者设置：</p>

<p><code>
- (NSOperationQueuePriority)queuePriority;
- (void)setQueuePriority:(NSOperationQueuePriority)p;
</code></p>

<p>工作之间也可有从属依赖关系，只有依赖的工作完成后才会执行：</p>

<p><code>
- (void)addDependency:(NSOperation *)op;
- (void)removeDependency:(NSOperation *)op;
</code></p>

<p>还可以通过下面接口设置运行NSOpration的子线程优先级：</p>

<p><code>
- (void)setQueuePriority:(NSOperationQueuePriority)priority;
</code></p>

<p>iOS4之后还可以往NSOperation上添加一个结束block，用于在工作执行结束之后的操作：</p>

<p><code>
- (void)setCompletionBlock:(void (^)(void))block;
</code></p>

<p>如果需要阻塞等待NSOperation工作结束(别在主线程这么干)，可以使用接口：</p>

<p><code>
- (void)waitUntilFinished;
</code></p>

<p>NSOperationQueue除了添加NSOperation外，也支持直接添加一个Block(iOS4之后)：</p>

<p><code>
- (void)addOperationWithBlock:(void (^)(void))block
</code></p>

<p>NSOperationQueue可以取消所有添加的工作：</p>

<p><code>
- (void)cancelAllOperations;
</code>
也可以阻塞式的等待所有工作结束(别在主线程这么干)：</p>

<p><code>
- (void)waitUntilAllOperationsAreFinished;
</code></p>

<p>在NSOperation对象中获得被添加的NSOperationQueue队列：</p>

<p><code>
+ (id)currentQueue
</code></p>

<p>要获得一个绑定在主线程的NSOperationQueue队列：</p>

<p><code>
+ (id)mainQueue
</code></p>

<h3>NSInvocationOperation &amp; NSBlockOperation</h3>

<p>其实除非必要，简单的工作完全可以使用官方提供的NSOperation两个子类NSInvocationOperation和NSBlockOperation来实现。</p>

<p>NSInvocationOperation：</p>

<p>```
NSInvocationOperation* theOp = [[NSInvocationOperation alloc]</p>

<pre><code>                   initWithTarget:self                 
                      selector:@selector(myTaskMethod:)                                           
                        object:data];
</code></pre>

<p>```</p>

<p>NSBlockOperation:</p>

<p>```
NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{</p>

<pre><code>  NSLog(@"Beginning operation.\n");
  // Do some work.
</code></pre>

<p>   }];
```</p>

<p>接口非常简单，一看便会。</p>

<h3>Sample Code</h3>

<p>本文例子放在<a href="https://github.com/hrchen/ExamplesForBlog">Github</a>上（工程NSURLConnectionExample中的PTOperationDownloader）。</p>

<h3>参考资料</h3>

<p><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html">Concurrency Programming Guide</a></p>

<p><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html">NSOperation Class Reference</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block的引用循环问题 (ARC & non-ARC)]]></title>
    <link href="http://hrchen.com/2013/06/retain-cycle-in-block/"/>
    <updated>2013-06-27T00:32:00+08:00</updated>
    <id>http://hrchen.com/2013/06/retain-cycle-in-block</id>
    <content type="html"><![CDATA[<p>2010年WWDC发布iOS4时Apple对Objective-C进行了一次重要的升级：支持Block。说到底这东西就是闭包，其他高级语音例如Java和C++已有支持，第一次使用Block感觉满简单好用的，但是慢慢也遇到很多坑。本文聊聊ARC和non-ARC下Block使用中的引用循环问题，最近遇到了好几次这种问题，还是深入记录下。先来套<a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">题目</a>热热身，貌似能够全部答对的人蛮少的</p>

<h3>Block实现原理</h3>

<p>首先探究下Block的实现原理，由于Objective-C是C语言的超集，既然OC中的NSObject对象其实是由C语言的struct+isa指针实现的，那么Block的内部实现估计也一样，以下三篇Blog对Block的实现机制做了详细研究：</p>

<ul>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/">A look inside blocks: Episode 1</a></li>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/">A look inside blocks: Episode 2</a></li>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-3/">A look inside blocks: Episode 3</a></li>
</ul>


<p>虽然实现细节看着头痛，不过发现Block果然是和OC中的NSObject类似，也是用struct实现出来的东西。这个是LLVM项目compiler-rt分析的block头文<a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h">Block_private.h</a>头文件中关于Block的struct声明：</p>

<!--more-->


<p>```
struct Block_descriptor {</p>

<pre><code>unsigned long int reserved;
unsigned long int size;
void (*copy)(void *dst, void *src);
void (*dispose)(void *);
</code></pre>

<p>};</p>

<p>struct Block_layout {</p>

<pre><code>void *isa;
int flags;
int reserved;
void (*invoke)(void *, ...);
struct Block_descriptor *descriptor;
/* Imported variables. */
</code></pre>

<p>};</p>

<p>```</p>

<p>我们发现Block_layout中也有一个isa指针，像极了NSobject内部实现struct中的isa指针。这里的isa可能指向三种类型之一的Block：</p>

<ul>
<li>_NSConcreteGlobalBlock：全局类型Block，在编译器就已经确定，直接放在代码段__TEXT上。直接在NSLog中打印的类型为__NSGlobalBlock__。</li>
<li>_NSConcreteStackBlock：位于栈上分配的Block，即__NSStaclBlock__。</li>
<li>_NSConcreteMallocBlock：位于堆上分配的Block，即__NSMallocBlock__。</li>
</ul>


<p>为什么会有这么多种类呢？首先来看全局类型Block，看例子：</p>

<p>```
void addBlock(NSMutableArray *array) {
  [array addObject:^{</p>

<pre><code>printf("global block\n");
</code></pre>

<p>  }];
}</p>

<p>void example() {
  NSMutableArray *array = [NSMutableArray array];
  addBlock(array);
  void (^block)() = [array objectAtIndex:0];
  block();
}</p>

<p>```
为什么addBlock中添加到array中的Block属于全局Block呢？因为它不需要运行时(Runtime)任何的状态来改变行为，不需要放在堆上或者栈上，直接编译后在代码段中即可，就像个c函数一样。这种类型的Block在ARC和non-ARC情况下没有差别。</p>

<p>这个Block访问了作用域外的变量d，在实现上就是这个block会多一个成员变量对应这个d，在赋值<sup>block</sup>时会将方法exmpale中的d变量值复制到成员变量中，从而实现访问。</p>

<p>```
void example() {</p>

<pre><code>int d = 5;
void (^block)() = ^() {
    printf("%d\n", d);
};
block();
</code></pre>

<p>}
```</p>

<p>如果要修改d呢？：</p>

<p>```
void example() {</p>

<pre><code>int d = 5;
void (^block)() = ^() {
    d++;
    printf("%d\n", d);
};
block();
printf("%d\n", d);
</code></pre>

<p>}
<code>``
由于局部变量d和这个block的实现不在同一作用域，仅仅在调用过程中用到了值传递，所以不能直接修改，而需要加一个标识符</code><strong>block int d = 5;`，那么block就可以实现对这个局部变量的修改了。如果是这种</strong>block标识的变量，在Block实现中不再是简单的一个成员变量，而是对应一个新的结构体表示这个<strong>block变量。</strong>block的本质是引入了一个新的<strong>Block_byref<em>{$var_name}</em>{$index}结构体，被</strong>block关键字修饰的变量就被放到这个结构体中。另外，block结构体通过引入<em><em>Block_byref</em>{$var_name}</em>{$index}指针类型的成员，得以间接访问到Block的外部变量。这样对Block外的变量访问从值传递转变为引用，从而有了修改内容的能力。</p>

<p>正常我们使用Block是在栈上生成的，离开了栈作用域便释放了，如果copy一个Block，那么会将这个Block copy到堆上分配，这样就不再受栈的限制，可以随意使用啦。例如：</p>

<p>```
typedef void (^TestBlock)();</p>

<p>TestBlock getBlock() {
  char e = 'E';
  void (^returnedBlock)() = ^{</p>

<pre><code>printf("%c\n", e);
</code></pre>

<p>  };
  return returnedBlock;
}</p>

<p>void example() {
  TestBlock block = getBlock();
  block();
}
```</p>

<p>函数getBlock中声明并赋值的returnedBlock，一开始是在栈上分配的，属于NSStackBlock，如果是non-ARC情况下return这个NSStackBlock，那么其实已经被销毁了，在函数中example()使用时就会crash。如果是ARC情况下，getBlock返回的block会自动copy到堆上，那么block的类型就是NSMallocBlock，可以在example()中继续使用。要在Non-ARC情况下正常运行，那么就应该修改为：</p>

<p>```
TestBlock getBlock() {
  char e = 'E';
  void (^returnedBlock)() = ^{</p>

<pre><code>printf("%c\n", e);
</code></pre>

<p>  };
  return [[returnedBlock copy] autorelease];
}
```</p>

<h3>Block中的循环引用问题</h3>

<p>扯了这么多，回到Block的循环引用问题，由于我们很多行为会导致Block的copy，而当Block被copy时，会对block中用到的对象产生强引用(ARC下)或者引用计数加一(non-ARC下)。</p>

<p>如果遇到这种情况：</p>

<p>```
@property(nonatomic, readwrite, copy) completionBlock completionBlock;</p>

<p>//========================================
self.completionBlock = ^ {</p>

<pre><code>    if (self.success) {
        self.success(self.responseData);
    }
}
</code></pre>

<p>};
```
对象有一个Block属性，然而这个Block属性中又引用了对象的其他成员变量，那么就会对这个变量本身产生强应用，那么变量本身和他自己的Block属性就形成了循环引用。在ARC下需要修改成这样：</p>

<p>```
@property(nonatomic, readwrite, copy) completionBlock completionBlock;</p>

<p>//========================================
__weak typeof(self) weakSelf = self;
self.completionBlock = ^ {</p>

<pre><code>if (weakSelf.success) {
    weakSelf.success(weakSelf.responseData);
}
</code></pre>

<p>};
<code>``
也就是生成一个对自身对象的弱引用，如果是倒霉催的项目还需要支持iOS4.3，就用\_\_unsafe_unretained替代\_\_weak。如果是non-ARC环境下就将\_\_weak替换为\_\_block即可。non-ARC情况下，\_\_block变量的含义是在Block中引入一个新的结构体成员变量指向这个\_\_block变量，那么</code>__block typeof(self) weakSelf = self;`就表示Block别再对self对象retain啦，这就打破了循环引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block的引用循环问题 (ARC & non-ARC)]]></title>
    <link href="http://hrchen.com/2013/06/retain-cycle-in-block/"/>
    <updated>2013-06-27T00:32:00+08:00</updated>
    <id>http://hrchen.com/2013/06/retain-cycle-in-block</id>
    <content type="html"><![CDATA[<p>2010年WWDC发布iOS4时Apple对Objective-C进行了一次重要的升级：支持Block。说到底这东西就是闭包，其他高级语音例如Java和C++已有支持，第一次使用Block感觉满简单好用的，但是慢慢也遇到很多坑。本文聊聊ARC和non-ARC下Block使用中的引用循环问题，最近遇到了好几次这种问题，还是深入记录下。先来套<a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">题目</a>热热身，貌似能够全部答对的人蛮少的</p>

<h3>Block实现原理</h3>

<p>首先探究下Block的实现原理，由于Objective-C是C语言的超集，既然OC中的NSObject对象其实是由C语言的struct+isa指针实现的，那么Block的内部实现估计也一样，以下三篇Blog对Block的实现机制做了详细研究：</p>

<ul>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/">A look inside blocks: Episode 1</a></li>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/">A look inside blocks: Episode 2</a></li>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-3/">A look inside blocks: Episode 3</a></li>
</ul>


<p>虽然实现细节看着头痛，不过发现Block果然是和OC中的NSObject类似，也是用struct实现出来的东西。这个是LLVM项目compiler-rt分析的block头文<a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h">Block_private.h</a>头文件中关于Block的struct声明：</p>

<!--more-->


<p>```
struct Block_descriptor {</p>

<pre><code>unsigned long int reserved;
unsigned long int size;
void (*copy)(void *dst, void *src);
void (*dispose)(void *);
</code></pre>

<p>};</p>

<p>struct Block_layout {</p>

<pre><code>void *isa;
int flags;
int reserved;
void (*invoke)(void *, ...);
struct Block_descriptor *descriptor;
/* Imported variables. */
</code></pre>

<p>};</p>

<p>```</p>

<p>我们发现Block_layout中也有一个isa指针，像极了NSobject内部实现struct中的isa指针。这里的isa可能指向三种类型之一的Block：</p>

<ul>
<li>_NSConcreteGlobalBlock：全局类型Block，在编译器就已经确定，直接放在代码段__TEXT上。直接在NSLog中打印的类型为__NSGlobalBlock__。</li>
<li>_NSConcreteStackBlock：位于栈上分配的Block，即__NSStaclBlock__。</li>
<li>_NSConcreteMallocBlock：位于堆上分配的Block，即__NSMallocBlock__。</li>
</ul>


<p>为什么会有这么多种类呢？首先来看全局类型Block，看例子：</p>

<p>```
void addBlock(NSMutableArray *array) {
  [array addObject:^{</p>

<pre><code>printf("global block\n");
</code></pre>

<p>  }];
}</p>

<p>void example() {
  NSMutableArray *array = [NSMutableArray array];
  addBlock(array);
  void (^block)() = [array objectAtIndex:0];
  block();
}</p>

<p>```
为什么addBlock中添加到array中的Block属于全局Block呢？因为它不需要运行时(Runtime)任何的状态来改变行为，不需要放在堆上或者栈上，直接编译后在代码段中即可，就像个c函数一样。这种类型的Block在ARC和non-ARC情况下没有差别。</p>

<p>这个Block访问了作用域外的变量d，在实现上就是这个block会多一个成员变量对应这个d，在赋值<sup>block</sup>时会将方法exmpale中的d变量值复制到成员变量中，从而实现访问。</p>

<p>```
void example() {</p>

<pre><code>int d = 5;
void (^block)() = ^() {
    printf("%d\n", d);
};
block();
</code></pre>

<p>}
```</p>

<p>如果要修改d呢？：</p>

<p>```
void example() {</p>

<pre><code>int d = 5;
void (^block)() = ^() {
    d++;
    printf("%d\n", d);
};
block();
printf("%d\n", d);
</code></pre>

<p>}
<code>``
由于局部变量d和这个block的实现不在同一作用域，仅仅在调用过程中用到了值传递，所以不能直接修改，而需要加一个标识符</code><strong>block int d = 5;`，那么block就可以实现对这个局部变量的修改了。如果是这种</strong>block标识的变量，在Block实现中不再是简单的一个成员变量，而是对应一个新的结构体表示这个<strong>block变量。</strong>block的本质是引入了一个新的<strong>Block_byref<em>{$var_name}</em>{$index}结构体，被</strong>block关键字修饰的变量就被放到这个结构体中。另外，block结构体通过引入<em><em>Block_byref</em>{$var_name}</em>{$index}指针类型的成员，得以间接访问到Block的外部变量。这样对Block外的变量访问从值传递转变为引用，从而有了修改内容的能力。</p>

<p>正常我们使用Block是在栈上生成的，离开了栈作用域便释放了，如果copy一个Block，那么会将这个Block copy到堆上分配，这样就不再受栈的限制，可以随意使用啦。例如：</p>

<p>```
typedef void (^TestBlock)();</p>

<p>TestBlock getBlock() {
  char e = 'E';
  void (^returnedBlock)() = ^{</p>

<pre><code>printf("%c\n", e);
</code></pre>

<p>  };
  return returnedBlock;
}</p>

<p>void example() {
  TestBlock block = getBlock();
  block();
}
```</p>

<p>函数getBlock中声明并赋值的returnedBlock，一开始是在栈上分配的，属于NSStackBlock，如果是non-ARC情况下return这个NSStackBlock，那么其实已经被销毁了，在函数中example()使用时就会crash。如果是ARC情况下，getBlock返回的block会自动copy到堆上，那么block的类型就是NSMallocBlock，可以在example()中继续使用。要在Non-ARC情况下正常运行，那么就应该修改为：</p>

<p>```
TestBlock getBlock() {
  char e = 'E';
  void (^returnedBlock)() = ^{</p>

<pre><code>printf("%c\n", e);
</code></pre>

<p>  };
  return [[returnedBlock copy] autorelease];
}
```</p>

<h3>Block中的循环引用问题</h3>

<p>扯了这么多，回到Block的循环引用问题，由于我们很多行为会导致Block的copy，而当Block被copy时，会对block中用到的对象产生强引用(ARC下)或者引用计数加一(non-ARC下)。</p>

<p>如果遇到这种情况：</p>

<p>```
@property(nonatomic, readwrite, copy) completionBlock completionBlock;</p>

<p>//========================================
self.completionBlock = ^ {</p>

<pre><code>    if (self.success) {
        self.success(self.responseData);
    }
}
</code></pre>

<p>};
```
对象有一个Block属性，然而这个Block属性中又引用了对象的其他成员变量，那么就会对这个变量本身产生强应用，那么变量本身和他自己的Block属性就形成了循环引用。在ARC下需要修改成这样：</p>

<p>```
@property(nonatomic, readwrite, copy) completionBlock completionBlock;</p>

<p>//========================================
__weak typeof(self) weakSelf = self;
self.completionBlock = ^ {</p>

<pre><code>if (weakSelf.success) {
    weakSelf.success(weakSelf.responseData);
}
</code></pre>

<p>};
<code>``
也就是生成一个对自身对象的弱引用，如果是倒霉催的项目还需要支持iOS4.3，就用\_\_unsafe_unretained替代\_\_weak。如果是non-ARC环境下就将\_\_weak替换为\_\_block即可。non-ARC情况下，\_\_block变量的含义是在Block中引入一个新的结构体成员变量指向这个\_\_block变量，那么</code>__block typeof(self) weakSelf = self;`就表示Block别再对self对象retain啦，这就打破了循环引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个异步网络请求问题：关于NSURLConnection和NSRunLoopCommonModes]]></title>
    <link href="http://hrchen.com/2013/06/nsurlconnection-with-nsrunloopcommonmodes/"/>
    <updated>2013-06-24T16:15:00+08:00</updated>
    <id>http://hrchen.com/2013/06/nsurlconnection-with-nsrunloopcommonmodes</id>
    <content type="html"><![CDATA[<p>我们开发App时，常常需要异步下载网络资源或者实现REST API调用，目前流行的HTTP库有<a href="https://github.com/pokeb/asi-http-request/">ASIHTTPRequest</a>（已经停止开发维护）和<a href="https://github.com/AFNetworking/AFNetworking">AFNetWorking</a>。两者实现异步网络请求的方式不太相同，ASIHTTPRequest使用的是一个公共独立子线程和CFNetWork API的技术：</p>

<p>```
+ (NSThread <em>)threadForRequest:(ASIHTTPRequest </em>)request
{</p>

<pre><code>if (networkThread == nil) {
    @synchronized(self) {
        if (networkThread == nil) {
            networkThread = [[NSThread alloc] initWithTarget:self selector:@selector(runRequests) object:nil];
            [networkThread start];
        }
    }
}
return networkThread;
</code></pre>

<p>}
```
AFNetWorking则是包装了NSOperation和NSURLConnection技术实现异步网络请求，然而它在NSOperation中真正启动NSURLConnection网络请求时，同样生成了一个公共独立子线程来Kick off网络请求：</p>

<p>```
+ (NSThread *)networkRequestThread {</p>

<pre><code>static NSThread *_networkRequestThread = nil;
static dispatch_once_t oncePredicate;
dispatch_once(&amp;oncePredicate, ^{
    _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
    [_networkRequestThread start];
});

return _networkRequestThread;
</code></pre>

<p>}
```</p>

<!-- more -->


<p>ASIHTTPRequest和AFNetWorking实际上都是使用一个公共独立子线程配合Run Loop来实现管理网络请求
。由于我在开发中需要一个简单的网络图片下载功能，直接使用第三方库需要添加太多文件，就写了一个类似Sample Code中PTNormalDownloaler下载类，当时遇到个tricky的问题。</p>

<p>首先，如果是直接调用NSURLConnection的initWithRequest:delegate:startImmediately:（第三个参数用YES，这个是designated initializer）或者方法initWithRequest:delegate:时，NSURLConnection会默认运行在NSDefaultRunLoopMode模式下，即使再使用scheduleInRunLoop:forMode:设置运行模式也没有用。如果NSURLConnection运行在NSDefaultRunLoopMode下，何为Run Loop的模式Mode，请参考这篇<a href="http://www.hrchen.com/2013/06/multi-threading-programming-of-ios-part-1/">Blog</a>），
这篇Blog提到NSDefaultRunLoopMode是Run Loop默认的运行模式，用于处理除了NSConnection对象的事件。
然而如果NSURLConnection是运行在NSDefaultRunLoopMode，而当前线程是主线程，并且UI上有类似滚动这样的操作，那么主线程的Run Loop会运行在UITrackingRunLoopMode下，就无法响应NSURLConnnection的回调。此时需要首先使用initWithRequest:delegate:startImmediately:（第三个参数为NO）生成NSURLConnection，再重新设置NSURLConnection的运行模式为NSRunLoopCommonModes，那么UI操作和回调的执行都将是非阻塞的，因为NSRunLoopCommonModes是一组run loop mode的集合，默认情况下包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。</p>

<p>```
- (void)start
{</p>

<pre><code>NSMutableURLRequest* request = [[NSMutableURLRequest alloc]   
            initWithURL:self.URL
            cachePolicy:NSURLCacheStorageNotAllowed
            timeoutInterval:self.timeoutInterval];
[request setHTTPMethod: @"GET"];
self.connection =[[NSURLConnection alloc] initWithRequest:request
                                                 delegate:self
                                         startImmediately:NO];
[self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
[self.connection start];
</code></pre>

<p>}</p>

<p>```</p>

<p>其次在调用PTNormalDownloaler的start方法时，如果是用GCD在其他线程中开始运行：</p>

<p>```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(){</p>

<pre><code>    [downloader start];
});
</code></pre>

<p>```
而非在主线程中运行：</p>

<p>```
[downloader performSelectorOnMainThread:@selector(start)</p>

<pre><code>                         withObject:nil 
                      waitUntilDone:YES];
</code></pre>

<p>```</p>

<p>你在GCD的全局队列里运行的PTNormalDownloaler中的不会得到NSURLConnection回调，而从主线程中启动NSURLConnection可以得到回调，这是由于在GCD全局队列中执行时没有运行Run Loop，那么NSURLConnection也就无法触发回调了。</p>

<p>当然在GCD的全局队列里启动NSURLConnection需要这样这样：</p>

<p>```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(){</p>

<pre><code>    [downloader start];
    NSLog(@"current worker thread: %@", [NSThread currentThread]);
    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
    NSLog(@"exit worker thread");
});
</code></pre>

<p>```</p>

<p>如果从主线程启动NSURLConntection，其回调会在主线程中被调用：</p>

<p><code>
2013-06-26 19:35:13.309 NSURLConnectionExample[22646:50b] connectionDidFinishLoading in main thread?: 1
</code></p>

<p>如果是在子线程启动NSURLConntection，其回调则会在子线程中被调用：</p>

<p><code>
2013-06-26 19:38:18.937 NSURLConnectionExample[22670:3903] connectionDidFinishLoading in main thread?: 0
</code></p>

<p>在主线程启动NSURLConnection会不会影响主线程的UI？影响肯定会有，但是网络IO本身不会影响，那是底层操作系统的事情，仅仅是网络IO结束后由主线程来处理回调而已。</p>

<p>样例程序里也实现了一个基于子线程的下载器PTThreadDownloader，与ASIHTTPRequest和AFNetWorking中的方法类似，生成一个公共子线程来启动NSURLConnection。这里没有必要对每个网络请求都生成一个后台子线程去启动NSURLConnection（例如上面那种用GCD扔到global queue的方式最终也是每次从线程池找到一个线程来启动NSURLConnection），因为底层网络IO并不是在这个子线程里去执行的，子线程仅仅用于响应NSURLConnection回调。不过公共子线程的方法会导致有一个子线程一直运行在后台，等待用户用它来启动NSURLConnection。</p>

<h3>Sample Code</h3>

<p>本文例子放在<a href="https://github.com/hrchen/ExamplesForBlog">Github</a>上（工程NSURLConnectionExample），可以根据文中的几种情况测试initWithRequest:delegate:startImmediately:第三个参数的影响以及回调问题，例子UI中的按钮每点击一次会产生一个下载PTNormalDownloaler对象并开始执行，如果这个NSURLConnection是运行在NSDefaultRunLoopMode模式下，那么上下滚动UI中的Table View，是不会触发NSURLConnection回调的，只有UI操作结束后才会触发。</p>
]]></content>
  </entry>
  
</feed>
