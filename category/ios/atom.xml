<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | hrchen's blogging]]></title>
  <link href="http://hrchen.com/category/ios/atom.xml" rel="self"/>
  <link href="http://hrchen.com/"/>
  <updated>2013-07-14T23:58:39+08:00</updated>
  <id>http://hrchen.com/</id>
  <author>
    <name><![CDATA[hrchen]]></name>
    <email><![CDATA[dr.hrchen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARC工程转换和开发注意事项]]></title>
    <link href="http://hrchen.com/2013/07/arc-transfer-and-notice/"/>
    <updated>2013-07-09T17:40:00+08:00</updated>
    <id>http://hrchen.com/2013/07/arc-transfer-and-notice</id>
    <content type="html"><![CDATA[<p>本文用于备份ARC工程转换流程和开发注意事项，ARC的意义不仅仅是开发效率的提高，更是一种思维方式的转变，不再考虑什么地方调用retain/release，而是利用对象的强/弱指针来控制对象所有权。</p>

<h3>ARC工程转换</h3>

<h4>Xcode工程设置</h4>

<p>1)  查看Xcode工程Build Settings设置中Builing Options中的Compiler选项，确保使用的是Apple LLVM compiler 3.0以上版本的编译器；</p>

<p><img src="/images/post/xcode-compiler.jpg"></p>

<p>2)  在Xcode工程的Build Settings开启ARC：搜索Objective-C Automatic Reference Counting；</p>

<p><img src="/images/post/xcode-arc.jpg"></p>

<!-- more -->


<p>3)  打开Xcode的Prefernece设置中的General，开启Coninue building after errors。</p>

<p><img src="/images/post/xcode-settings.jpg"></p>

<h4>开启ARC转换工具</h4>

<p>1) 打开Xcode->Edit->Refactor->Convert to Objective-C ARC…</p>

<p><img src="/images/post/xcode-refactor-arc.jpg"></p>

<p>2) 注意只选择本工程相关文件，第三方库如果一般不要进行ARC转换，如果有对应ARC版本库可以直接替换。</p>

<p><img src="/images/post/xcode-arc-check.jpg"></p>

<p>正常情况下不会顺利完成Check，会有大量需要手动修改的Error，常见的问题有以下这些：</p>

<p>1)  调用 [cell autorelease]、[object release]、[object retain]，直接删除即可，这种应该属于Checker的误报，正常是可以直接Refactor的。</p>

<p>2)  CoreFoundation对象与NSObject对象的转换，需要添加<strong>bridge, </strong>bridge_retained或者__bridge_trasfer。</p>

<p>CoreFoundation的对象例如CFStringRef有自己的引用计数，和Cocoa框架中的NSObject是不同的方法，ARC只对NSObject对象的引用计数有效。只要是生成CF对象的函数名中有含有Create, Copy, 或者Retain，就表示需要为它的引用计数负责，需要使用结束时CFRelease()将引用计数减一。</p>

<p>例如：如果使用了一个含有reate, Copy, 或者Retain的方法生成了一个CFStringRef name，那么在转换成NSString时，就需要写成<code>NSString *nameString = (__bridge_transfer NSString *)name;</code></p>

<ul>
<li>__bridge_transfer的含义表示将CF对象的管理权移至NSObject层由ARC负责，无需再用CFRelease()释放name这个CFStringRef。</li>
<li>__bridge_retained的含义相反，就是将一个NSObject对象转换成CF对象，并且引用计数加一，那么在CF层用完这个CF对象后，就需要使用CFRelease()释放该对象，因为内存管理权已经由NSobject层转移至CF层。</li>
<li>__bridge的含义表示在NSObject层和CF层引用计数都平衡，无需转移内存管理权。
例如如果使用不包含reate, Copy, 或者Retain的函数获得的CFStringRef name转换成NSString时，无需处理引用计数问题，因此可以这样转换：<code>NSString *nameString = (__bridge NSString *)name;</code></li>
</ul>


<p>除了上面三个关键字，还有两个宏CFBridgingRetain()和CFBridgingRelease()来控制CF层与NSObject层的引用计数平衡，不过实际上他们就是<strong>bridge_retained和</strong>bridge_transfer。</p>

<p>```
CFTypeRef CFBridgingRetain(id X)
{ return (__bridge_retained CFTypeRef)X; }</p>

<p>id CFBridgingRelease(CFTypeRef CF_CONSUMED X)
{ return (__bridge_transfer id)X; }
```</p>

<p>3)  NSInvocation方法
例如：</p>

<p><code>
NSString *date = @”test”;
[writeInvocation setArgument:&amp;data atIndex:2];
</code></p>

<p>NSInvocation在设置调用参数时会提示：<code>NSInvocation's setArgument is not safe to be used with an object with ownership other than __unsafe_unretained</code>
修改方法需要将传入的参数添加__unsafe_unretained关键字，即<code>NSString * __unsafe_unretained date = @”test”;</code></p>

<p>4)  NSAutoreleasePool
ARC下不再支持NSAutoreleasePool，需要使用@autoreleasepool{}替换。</p>

<p>5)  错误<code>Passing address of non-local object to __autoreleasing parameter for write-back</code>。
此错误通常是由于将非局部变量的地址传递给一个方法导致的，例如：
<code>
//_array 和_dict是成员变量而非局部变量
[CTViewController trainInfoList:&amp;_array forSeats:&amp;_dict];
</code>
处理方法也比较简单，生成一个临时局部变量即可：
<code>
NSArray *tempArray = nil;
NSDictionary *tempDict = nil;
[CTViewController trainInfoList:&amp;tempArray forSeats:&amp;tempDict];
_array = tempArray;
_dict = tempDict;
</code></p>

<h3>ARC开发注意事项</h3>

<p>1)  NSObject的 retain, release和autorelease都无需再调用，ARC会评估NSObject对象的生命周期，在编译器自动添加相应内存相关方法完成内存管理，并且会生成相应的dealloc方法，因此如果自定义的类如果没有需要内存管理外的操作(例如删除NSNotification的Observer以及将指向自己的delegate置为nil)，就无需再实现dealloc。</p>

<p>2)  不能在struct中使用NSObject对象的指针。</p>

<p>3)  使用@autoreleasepool{}取代NSAutoreleasePool。</p>

<p>4)  不再使用NSZone。</p>

<p>5)  新增属性关键字strong、weak、unsafe_unretained</p>

<p>6)  新增变量关键字<strong>strong、</strong>weak、<strong>unsafe_unretained、</strong>autoreleasing：
<strong>strong表示这个变量指针是强指针，指向的对象只要有强指针指向它就不会被销毁；
</strong>weak表示变量指针是弱指针，如果没有其他强指针指向这个对象时，这个对象就会被销毁，同时弱指针会置为nil；
<strong>unsafe_unretained和</strong>weak类似，除了在对象销毁后不会使这个<strong>unsafe_unretained指针置为nil，因此这个指针就变成悬空指针！
</strong>autoreleasing用于传递给方法的参数是引用传值，并且在返回时会autorelease。
正确的关键字写法：</p>

<p><code>
MyClass * __weak weakReference;
MyClass * __unsafe_unretained unsafeReference;
</code></p>

<p>7)  避免循环引用问题
循环引用问题一般在两个类对象相互引用和使用Block对象时出现，解决两个类对象相互引用问题，可以将其中一个引用声明为弱引用，就可以打破循环引用问题。
Block对象常见的循环引用问题如下：</p>

<p>```
MyViewController *myController = [[MyViewController alloc] init…];</p>

<p>myController.completionBlock= ^() {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil]; }; 
</code></pre>

<p>```
上面例子中会导致completionBlock和myController循环引用，正确的处理方法有两种：</p>

<ul>
<li>一是使用<strong>block关键字，之后将该</strong>block变量置为nil</li>
</ul>


<p>```
MyViewController * __block myController = [[MyViewController alloc] init…];</p>

<p>myController.completionBlock= ^() {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil]; 
myController = nil;
</code></pre>

<p>};
```</p>

<ul>
<li>二是使用__weak关键字</li>
</ul>


<p>```
MyViewController * <strong>block myController = [[MyViewController alloc] init…];
MyViewController * </strong>weak weakMyViewController = myController;</p>

<p>myController.completionBlock= ^() {</p>

<pre><code>[weakMyViewController dismissViewControllerAnimated:YES completion:nil]; 
</code></pre>

<p>};
```</p>

<p>8)  toll-free bridge问题</p>

<p>对于要使用Core Foundation的对象时，要注意对象生命周期的所有权问题，重点是三个关键字<strong>bridge, </strong>bridge_retained和__bridge_trasfer对CF对象和NS对象的转换，使用方法参见上节工程转换时候的说明。</p>

<p>9)  ARC时所有临时变量指针(栈内生成)都会初始化为nil。例如：</p>

<p>```
- (void)test {</p>

<pre><code>NSString *name; 
NSLog(@"name: %@", name); 
</code></pre>

<p>}
```
上面代码会打印nil。</p>

<p>10) 如果有不需要ARC管理的文件(例如还未支持ARC的第三方库)，可以在Xcode中设置工程Target的Build Phase中Compiler Source，不需要ARC管理的文件添加编译参数“-fno-objc-arc”。
<img src="/images/post/xcode-fno-objc-arc.jpg"></p>

<p>11) 在MRC情况下NSString * <strong>block myString是不会被retain的，但是ARC情况下NSString * </strong>block myString实际会被retian，如果需要和MRC下同样的语义，请使用：<strong>block NSString * </strong>unsafe_unretained myString 或者<strong>block NSString * </strong>weak myString。</p>

<p>12) iOS 4.*系统不支持weak语义，可以使用unsafe_unretained替代，但是可能导致悬空指针问题，需要小心对待。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几个有用的Objective-C新特性]]></title>
    <link href="http://hrchen.com/2013/07/modern-objective-c-until-2013/"/>
    <updated>2013-07-04T21:20:00+08:00</updated>
    <id>http://hrchen.com/2013/07/modern-objective-c-until-2013</id>
    <content type="html"><![CDATA[<p>Objective-C已经稳定在TIOBE编程语言排行榜前五名，2010年刚接触Objective-C还是因为公司在搞Mac版企业IM开发，那时候OC还几乎无人问津，这些年倒是风光无限，只能感叹当初踩对点了，不清楚未来10年又会有哪些语言流行起来，下一个会不会是<a href="http://golang.org/">go</a>？。这几年来Objective-C的进化速度也是非常快，Apple不断添加新的特性到Objective-C，例如ARC、Block等，以下挑些个人感觉对开发效率影响比较大的新特性来说：</p>

<h3>不用再写sythesize</h3>

<p>以前声明属性Property，都要在类的实现@implementation里将属性和成员变量做相应的synthesize，synthesize的含义是将属性和成员变量做关联。早期声明一个属性，需要同样声明一个成员变量，然后<code>@synthersize date=_date;</code>将属性与成员变量关联起来，后来可以无需声明成员变量，<code>@synthersize date=_date;</code>可以自动帮你声明一个名字为_date的成员变量，<code>@synthersize date</code>就是自动声明一个成员变量date。</p>

<p>Xcode4.4以后，synthesize关键字也不需要写了，例如<code>@property (nonatomic, readwrite, retain) NSDate *date;</code>编译器可以自动绑定并且生成对应的成员变量<code>NSDate *_date</code>，相当于是自动添加了<code>@synthesize date=_date;</code>。这样既不用再声明成员变量，也不要费神写@synthesize，方便不少。</p>

<!--more-->


<p>当然凡事有例外，如果同时实现了setter和getter方法，例如上面你实现了<code>-(void)setDate</code>和<code>-(NSDate *)date</code>，那么编译器就不会自动帮你synthesize。这里同时实现setter和getter方法是针对readwrite属性来说的，对于readonly属性，那么你实现了getter方法即<code>-(NSDate *)date</code>也同样不会自动绑定成员变量。</p>

<h3>成员方法的顺序</h3>

<p>以前在.m实现文件中实现方法时经常会引用其他成员方法，而如果引用的成员方法未在头文件或者匿名catrgory中声明，同时也不在引用者前面，那么编译器会报未找到该方法的错误。现在新的编译器中，只要在实现文件里的成员方法，在其他任何位置的方法中调用都不再报错，Nice!</p>

<h3>不一样的NSNumber、NSArray和NSDictionary</h3>

<p>最新的OC语法里还添加了许多类似脚本语言的特性，例如以前要生成NSNumber满费劲，都是[NSNumber numberWith***]的写法，太多冗余。现在方便了，可以用@符号替代，例如<code>[NSNumber numberWithChar:‘c’]</code>可以直接表示为<code>@'c'</code>，<code>[NSNumber numberWithInt:123]</code>直接表示为<code>@123</code>，<code>[NSNumber numberWithFloat:1.23f]</code>z直接写为<code>@1.23f</code>，其他类型同理变换。</p>

<p>NSArray的变化也是类似的，<code>[NSArray array]</code>就是<code>@[]</code>，<code>[NSArray arrayWithObject:x]</code>就是 <code>@[x]</code>，<code>[NSArray arrayWithObjects:x, y, z, nil]</code>就是<code>@[x, y, z]</code>，不过这种方式生成的是NSArray，要生成NSMutableArray呢？也简单，直接调用mutableCopy即可，例如<code>[@[x, y, z] mutableCopy]</code>。如果要访问第1个元素，以前需要写成<code>[array objectAtIndex:0]</code>，现在可以直接用<code>array[0]</code>访问，像极了脚本语言。</p>

<p>NSDictionary的变化和NSArray类似，不同的是用<code>@{}</code>,例如<code>[NSDictionary dictionaryWithObject:value forKey:key]</code>可以表示为<code>@{key: value}</code>。访问时也和大多数脚本语言一样，用<code>dict[key]</code>来获得键值对应的值。</p>

<p>至于以上简化的方法到底要不要用，还是看自己或者项目组的习惯了，个人建议是在符合统一编码规范的情况下，尽量拥抱变化，毕竟这些都是为了优化生产效率的变化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于+initialize和+load的坑]]></title>
    <link href="http://hrchen.com/2013/07/tricky-initialize-and-load/"/>
    <updated>2013-07-03T22:29:00+08:00</updated>
    <id>http://hrchen.com/2013/07/tricky-initialize-and-load</id>
    <content type="html"><![CDATA[<p>NSObject有两个特殊的类方法+initialize和+load。+initialize会在类的任何其他函数调用前被调用，因此也可以利用这个特性实现Singleton单例：</p>

<p>```
static Manager +theManager = nil;</p>

<ul>
<li><p>(void) initialize
{
  if (self == [Manager class])
  {
      theManager = [[Manager alloc] init];
  }
}</p></li>
<li><p>(Manager *)sharedObj
{
return theManager;
}
```</p></li>
</ul>


<p>+load方法是在所在类加载到系统的时候被调用，这通常会比+initialized调用的时机要早，不过通常由于运行环境还有太多不确定性，不建议在+load中调用实际的方法。虽然Apple文档里说+initialized和+load都只会被执行一次，但是这里有坑。</p>

<p>如果子类里没有实现+initialized而父类里面实现了+initialized，那么用到子类时，不是说一定要生成对象，+initialize是调用任何方法，包括类方法，例如[SubClass class]，那么父类的+initialized就会被执行两次！解决办法也很简单，就像开头的写法<code>if (self == [Manager class])</code>，先判断下是不是当前类的类型。</p>

<p>那么对于+load呢？如果你在类的实现中实现了+load，但是在这个类的Category中又实现了一个+load，那么这两个+load都会被调用。</p>

<p>既然这两个方法都是如此的诡异，所以除非必要，最好都不要在这两个方法中执行太多的操作，尤其是+load。绕过坑，远离危险。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程Part 3/3 - GCD]]></title>
    <link href="http://hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/"/>
    <updated>2013-07-02T21:20:00+08:00</updated>
    <id>http://hrchen.com/2013/07/multi-threading-programming-of-ios-part-3</id>
    <content type="html"><![CDATA[<p>前两部分介绍了NSThread、NSRunLoop和NSOperation的基本支持，本文聊聊iOS4发布时推出的神器GCD。</p>

<h3>前言</h3>

<p>GCD: Grand Central Dispatch，是一组用于实现并发编程的C接口。GCD是完全基于Objective-C的Block特性开发的，基本调用逻辑和NSOperation很像，都是将工作添加到一个队列，由系统来负责线程的生成和调度。由于是直接使用Block，因此比NSOperation更加方便，大大降低了多线程开发的门槛。示例：</p>

<p>```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>[self doTask];
NSLog(@"Fisinished");
</code></pre>

<p>});
```</p>

<p>另外，GCD是开源的喔：<a href="http://libdispatch.macosforge.org/">libdispatch</a></p>

<h3>Dispatch Queue</h3>

<p>要添加工作到队列Dispatch Queue中，这个队列可以是串行或者并行的，并行队列会尽可能的并发执行其中的工作任务，而串行队列每次只能运行一个工作任务。</p>

<!--more-->


<p>目前GCD中有三种类型的Dispatch Queue：</p>

<ul>
<li>Main Queue：关联到主线程的队列，可以使用函数dispatch_get_main_queue()获得，加到这个队列中的工作都会分发到主线程运行。主线程只有一个，因此很明显这个是串行队列，每次运行一个工作。</li>
<li>Global Queue：全局队列是并发队列，又根据优先级细分为高优先级、默认优先级和低优先级三种。通过dispatch_get_global_queue加上优先级参数获得这个全局队列，例如<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code></li>
<li>自定义Queue：自己创建一个队列，只能是串行队列，可以理解为最终有一个独立的子线程帮你运行添加到这个队列中的工作任务。通过函数dispatch_queue_create创建，例如<code>dispatch_queue_create(@"com.kiloapp.test", 0)</code> ,第二个参数仅作保留，目前没有意义，第一个参数是队列的名字，Apple建议使用反DNS型的名字命名，防止重名。</li>
</ul>


<h3>添加工作任务</h3>

<p>添加工作任务到队列也非常简单，调用函数dispatch_async()，两个参数，一个就是Dispatch Queue，另一个是一个包含工作的Block，就像本文开头的示例一样。dispatch_async函数是非阻塞的，调用后会立刻返回，工作由系统分配线程去执行工作。因此另一种常见的使用模式是：</p>

<p>```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>[self doHardWorkInBackground];
dispatch_async(dispatch_get_main_queue(), ^{
    [self updateUI];
});
</code></pre>

<p>});
```
可以将一些耗时的工作添加到全局队列，让系统分配线程在后台中去做，完成后，再次调用GCD的主队列去完成UI相关的工作，这样做就不会因为大量的非UI相关工作加重主线程负担，加快UI事件响应。</p>

<p>与dispatch_async对应的有一个dispatch_sync方法，它是阻塞式的，会一直等到添加的工作完成后才会返回。</p>

<p>NSOperation是没法直接使用的，它只是提供了一个工作的基本逻辑，具体实现还是需要你通过定义自己的NSOperation子类来获得。如果有必要也可以不将NSOperation加入到一个NSOperationQueue中去执行，直接调用起<code>-start</code>也可以直接执行。</p>

<h3>Dispatch Group</h3>

<p>GCD确实非常简单好用，不过有些情况还是有点问题，例如：</p>

<p>```
for(id obj in array)
{</p>

<pre><code>[self doWorkOnItem:obj];
</code></pre>

<p>}
[self doWorkOnArray:array];
```</p>

<p>前半部分可以用GCD得到处理性能的提升：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
for(id obj in array)</p>

<pre><code>dispatch_async(queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>[self doWorkOnArray:array];
<code>``
问题是</code>[self doWorkOnArray:array];<code>原先是在全部数组各个成员的工作完成后才会执行的，现在由于dispatch_async是非阻塞的，</code>[self doWorkOnArray:array];`很有可能在各个成员的工作完成前就运行了，这明显不符合我们的目的。如果将dispatch_async改成dispatch_sync可以解决问题，但是和原来的方法一样失去了并行的好处，也没有意义了。</p>

<p>针对这种情况，GCD提供了Dispatch Group可以将一组工作集合在一起，等待这组工作完成后再继续运行。dispatch_group_create函数可以用来创建这个Group：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(id obj in array)</p>

<pre><code>dispatch_group_async(group, queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
[self doWorkOnArray:array];
```</p>

<p>方法是不是很简单，将并发的工作用dispatch_group_async添加到一个Group和全局队列中，dispatch_group_wait会等待这些工作完成后再返回，这样你就可以再运行<code>[self doWorkOnArray:array];</code>。</p>

<p>不过有点不好的是dispatch_group_wait会阻塞当前线程，如果当前是主线程岂不是不好，有更绝的：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(id obj in array)</p>

<pre><code>dispatch_group_async(group, queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>dispatch_group_notify(group, queue, ^{</p>

<pre><code>[self doWorkOnArray:array];
</code></pre>

<p>});
dispatch_release(group);
```
dispatch_group_notify函数可以将这个Group完成后的工作也同样添加到队列中（如果是需要更新UI，这个队列也可以是主队列），总之这样做就完全不会阻塞当前线程了。</p>

<p>如果就是要同步的执行对数组元素的逐个操作，GCD也提供了一个简便的dispatch_apply函数：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply([array count], queue, ^(size_t index){</p>

<pre><code>[self doWorkOnItem:obj:[array objectAtIndex:index]];
</code></pre>

<p>});
[self doWorkOnArray:array];
```</p>

<p>要了解更全的接口，查看《Grand Central Dispatch (GCD) Reference》。</p>

<h3>其他有趣的特性</h3>

<ul>
<li>Dispatch Source</li>
</ul>


<p>Run Loop有Input Source，GCD也同样支持一系列事件，就是监听事件发生后会执行一个Block形式的Handler。Dispatch Source支持的事件源类型有：Timer源、signal信号源、描述符(文件或者网络描述符)源、进程源、Port源、自定义源。当然有些源由于iOS系统原因肯定是无法使用的，例如进程源、Port源、、signal信号源。</p>

<p>举个自定义源的例子，假如我们在处理上面那个数组时要在UI中显示一个进度条：</p>

<p>```
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());</p>

<p>dispatch_source_set_event_handler(source, ^{</p>

<pre><code>[progressIndicator incrementBy:dispatch_source_get_data(source)];
</code></pre>

<p>});
dispatch_resume(source);</p>

<p>dispatch_apply([array count], globalQueue, ^(size_t index) {</p>

<pre><code>[self doWorkOnItem:obj:[array objectAtIndex:index]];
dispatch_source_merge_data(source, 1);
</code></pre>

<p>});
```
dispatch source创建后是出于suspend状态的，必须使用dispatch_resume来恢复，dispatch_apply中每处理一个数组元素会调用dispatch_source_merge_data加1，那么这个source的事件handler就可以通过dispatch_source_get_data拿到source的数据。</p>

<ul>
<li>单例</li>
</ul>


<p>传统我们实现单例是这样：</p>

<p>```
+ (id)sharedManager
{</p>

<pre><code>static Manager *theManager = nil;
@synchronized([Manager class])
{
    if(!theManager)
        theManager = [[Manager alloc] init];
}
return theManager;
</code></pre>

<p>}</p>

<p>```
这个的成本还是有点高，每次访问都会有同步锁，而GCD有个dispatch_once方法(类似于<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_once.html">pthread_once</a>)可以保证只运行一次初始化：</p>

<p>```
+ (id)sharedWhatever
{</p>

<pre><code>static dispatch_once_t pred;
static Manager *theManager = nil;
dispatch_once(&amp;pred, ^{
    theManager = [[Manager alloc] init];
});
return theManager;
</code></pre>

<p>}
```</p>

<ul>
<li>信号量Semaphore</li>
</ul>


<p>和其他多线程技术一样，GCD也支持信号量，dispatch_semaphore_create用于创建，dispatch_semaphore_signal用于通知，dispatch_semaphore_wait用于等待。</p>

<h3>参考资料</h3>

<p><a href="https://developer.apple.com/library/mac/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html">Grand Central Dispatch (GCD) Reference</a></p>

<p><a href="https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html">Blocks Programming Topics</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个NSURLConnectionDelegate的坑]]></title>
    <link href="http://hrchen.com/2013/06/tricky-nsurlconnectiondelegate/"/>
    <updated>2013-06-30T04:20:00+08:00</updated>
    <id>http://hrchen.com/2013/06/tricky-nsurlconnectiondelegate</id>
    <content type="html"><![CDATA[<p>NSURLConnection的坑还是蛮多的，上次是<a href="http://www.hrchen.com/2013/06/nsurlconnection-with-nsrunloopcommonmodes/">RunLoopMode的问题</a>，这次是关于NSURLConnectionDelegate。</p>

<p>NSURLConnection的代理Protocol定义有三类：NSURLConnectionDelegate、NSURLConnectionDataDelegate和NSURLConnectionDownloadDelegate。</p>

<ul>
<li>NSURLConnectionDelegate：所有类型NSURLConnection的基础代理方法，都是Optional的方法，主要是涉及SSL/TSL加密的相关接口。</li>
</ul>


<p>```
@optional
- (void)connection:(NSURLConnection <em>)connection didFailWithError:(NSError </em>)error;
- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection <em>)connection;
- (void)connection:(NSURLConnection </em>)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;</p>

<p>```
* NSURLConnectionDataDelegate：用于将网络请求的数据存放到内存中(以NSData的形式)的代理方法。所有方法都是Optional的。</p>

<!--more-->


<p>```
@optional
- (NSURLRequest <em>)connection:(NSURLConnection </em>)connection willSendRequest:(NSURLRequest <em>)request redirectResponse:(NSURLResponse </em>)response;
- (void)connection:(NSURLConnection <em>)connection didReceiveResponse:(NSURLResponse </em>)response;</p>

<ul>
<li><p>(void)connection:(NSURLConnection <em>)connection didReceiveData:(NSData </em>)data;</p></li>
<li><p>(NSInputStream <em>)connection:(NSURLConnection </em>)connection needNewBodyStream:(NSURLRequest *)request;</p></li>
<li><p>(void)connection:(NSURLConnection *)connection   didSendBodyData:(NSInteger)bytesWritten
                                               totalBytesWritten:(NSInteger)totalBytesWritten
                                       totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite;</p></li>
<li><p>(NSCachedURLResponse <em>)connection:(NSURLConnection </em>)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</p></li>
<li><p>(void)connectionDidFinishLoading:(NSURLConnection *)connection;</p></li>
</ul>


<p>```
* NSURLConnectionDownloadDelegate：用于将网络资源直接保存到文件中的代理方法，除了connectionDidFinishDownloading:destinationURL:都是Optional的方法。connectionDidFinishDownloading:destinationURL回调可以告知你下载的网络数据最终存放的文件位置，正常都是在iPhone应用沙盒的/tmp目录下。</p>

<p>```
@optional
- (void)connection:(NSURLConnection <em>)connection didWriteData:(long long)bytesWritten totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes;
- (void)connectionDidResumeDownloading:(NSURLConnection </em>)connection totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes;</p>

<p>@required
- (void)connectionDidFinishDownloading:(NSURLConnection <em>)connection destinationURL:(NSURL </em>) destinationURL;</p>

<p>```</p>

<p>由于生成NSURLConnectin对象传入delegate参数时类型就是id，而不是传统id&lt;***Delegate>形式，那么如何确定当前代理实现的是什么类型的NSURLConnectionDelegate代理呢？方法也很诡异，如果你的代理实现了connectionDidFinishDownloading:destinationURL:，那么就表示你要实现的是NSURLConnectionDownloadDelegate，NSURLConnectionDataDelegate中的connection:DidReceiveData就不会得到回调，即使你实现了它。道理很简单，这两类代理一个是用于将下载数据保存到文件上，另一个是保存到内存中，只能两者居其一。</p>

<p>故事还没有结束 ，如果你实现了connectionDidFinishDownloading:destinationURL并且想通过回到得到的destinationURL读取保存数据的文件时，令人惊讶的发现这个文件居然不存在，因为这类NSURLConnectionDataDelegate回调是用于Newsstand类型的App开发的，用于将杂志等信息保存到本地文件。实在想不通为什么只有Newsstand类型App才能用这组接口，很多开发者早已发了bug报告给Apple，Apple也已经确认，但是从iOS5到了iOS7，这个“bug”还是没有被修复。</p>

<p>附带我在Stackoverflow上的<a href="http://stackoverflow.com/questions/11047169/how-may-delegate-method-from-one-protocol-prevent-execution-of-another-one-from/17369617#17369617">回答</a>。</p>
]]></content>
  </entry>
  
</feed>
