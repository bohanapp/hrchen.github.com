<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | hrchen's blogging]]></title>
  <link href="http://hrchen.com/category/ios/atom.xml" rel="self"/>
  <link href="http://hrchen.com/"/>
  <updated>2013-07-11T01:18:09+08:00</updated>
  <id>http://hrchen.com/</id>
  <author>
    <name><![CDATA[hrchen]]></name>
    <email><![CDATA[dr.hrchen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARC工程转换和开发注意事项]]></title>
    <link href="http://hrchen.com/2013/07/arc-transfer-and-notice/"/>
    <updated>2013-07-09T17:40:00+08:00</updated>
    <id>http://hrchen.com/2013/07/arc-transfer-and-notice</id>
    <content type="html"><![CDATA[<p>本文用于备份ARC工程转换流程和开发注意事项，ARC的意义不仅仅是开发效率的提高，更是一种思维方式的转变，不再考虑什么地方调用retain/release，而是利用对象的强/弱指针来控制对象所有权。</p>

<h3>ARC工程转换</h3>

<h4>Xcode工程设置</h4>

<p>1)  查看Xcode工程Build Settings设置中Builing Options中的Compiler选项，确保使用的是Apple LLVM compiler 3.0以上版本的编译器；</p>

<p><img src="/images/post/xcode-compiler.jpg"></p>

<p>2)  在Xcode工程的Build Settings开启ARC：搜索Objective-C Automatic Reference Counting；</p>

<p><img src="/images/post/xcode-arc.jpg"></p>

<!-- more -->


<p>3)  打开Xcode的Prefernece设置中的General，开启Coninue building after errors。</p>

<p><img src="/images/post/xcode-settings.jpg"></p>

<h4>开启ARC转换工具</h4>

<p>1) 打开Xcode->Edit->Refactor->Convert to Objective-C ARC…</p>

<p><img src="/images/post/xcode-refactor-arc.jpg"></p>

<p>2) 注意只选择本工程相关文件，第三方库如果一般不要进行ARC转换，如果有对应ARC版本库可以直接替换。</p>

<p><img src="/images/post/xcode-arc-check.jpg"></p>

<p>正常情况下不会顺利完成Check，会有大量需要手动修改的Error，常见的问题有以下这些：</p>

<p>1)  调用 [cell autorelease]、[object release]、[object retain]，直接删除即可，这种应该属于Checker的误报，正常是可以直接Refactor的。</p>

<p>2)  CoreFoundation对象与NSObject对象的转换，需要添加<strong>bridge, </strong>bridge_retained或者__bridge_trasfer。</p>

<p>CoreFoundation的对象例如CFStringRef有自己的引用计数，和Cocoa框架中的NSObject是不同的方法，ARC只对NSObject对象的引用计数有效。只要是生成CF对象的函数名中有含有Create, Copy, 或者Retain，就表示需要为它的引用计数负责，需要使用结束时CFRelease()将引用计数减一。</p>

<p>例如：如果使用了一个含有reate, Copy, 或者Retain的方法生成了一个CFStringRef name，那么在转换成NSString时，就需要写成<code>NSString *nameString = (__bridge_transfer NSString *)name;</code></p>

<ul>
<li>__bridge_transfer的含义表示将CF对象的管理权移至NSObject层由ARC负责，无需再用CFRelease()释放name这个CFStringRef。</li>
<li>__bridge_retained的含义相反，就是将一个NSObject对象转换成CF对象，并且引用计数加一，那么在CF层用完这个CF对象后，就需要使用CFRelease()释放该对象，因为内存管理权已经由NSobject层转移至CF层。</li>
<li>__bridge的含义表示在NSObject层和CF层引用计数都平衡，无需转移内存管理权。
例如如果使用不包含reate, Copy, 或者Retain的函数获得的CFStringRef name转换成NSString时，无需处理引用计数问题，因此可以这样转换：<code>NSString *nameString = (__bridge NSString *)name;</code></li>
</ul>


<p>除了上面三个关键字，还有两个宏CFBridgingRetain()和CFBridgingRelease()来控制CF层与NSObject层的引用计数平衡，不过实际上他们就是<strong>bridge_retained和</strong>bridge_transfer。</p>

<p>```
CFTypeRef CFBridgingRetain(id X)
{ return (__bridge_retained CFTypeRef)X; }</p>

<p>id CFBridgingRelease(CFTypeRef CF_CONSUMED X)
{ return (__bridge_transfer id)X; }
```</p>

<p>3)  NSInvocation方法
例如：</p>

<p><code>
NSString *date = @”test”;
[writeInvocation setArgument:&amp;data atIndex:2];
</code></p>

<p>NSInvocation在设置调用参数时会提示：<code>NSInvocation's setArgument is not safe to be used with an object with ownership other than __unsafe_unretained</code>
修改方法需要将传入的参数添加__unsafe_unretained关键字，即<code>NSString * __unsafe_unretained date = @”test”;</code></p>

<p>4)  NSAutoreleasePool
ARC下不再支持NSAutoreleasePool，需要使用@autoreleasepool{}替换。</p>

<p>5)  错误<code>Passing address of non-local object to __autoreleasing parameter for write-back</code>。
此错误通常是由于将非局部变量的地址传递给一个方法导致的，例如：
<code>
//_array 和_dict是成员变量而非局部变量
[CTViewController trainInfoList:&amp;_array forSeats:&amp;_dict];
</code>
处理方法也比较简单，生成一个临时局部变量即可：
<code>
NSArray *tempArray = nil;
NSDictionary *tempDict = nil;
[CTViewController trainInfoList:&amp;tempArray forSeats:&amp;tempDict];
_array = tempArray;
_dict = tempDict;
</code></p>

<h3>ARC开发注意事项</h3>

<p>1)  NSObject的 retain, release和autorelease都无需再调用，ARC会评估NSObject对象的生命周期，在编译器自动添加相应内存相关方法完成内存管理，并且会生成相应的dealloc方法，因此如果自定义的类如果没有需要内存管理外的操作(例如删除NSNotification的Observer以及将指向自己的delegate置为nil)，就无需再实现dealloc。</p>

<p>2)  不能在struct中使用NSObject对象的指针。</p>

<p>3)  使用@autoreleasepool{}取代NSAutoreleasePool。</p>

<p>4)  不再使用NSZone。</p>

<p>5)  新增属性关键字strong、weak、unsafe_unretained</p>

<p>6)  新增变量关键字<strong>strong、</strong>weak、<strong>unsafe_unretained、</strong>autoreleasing：
<strong>strong表示这个变量指针是强指针，指向的对象只要有强指针指向它就不会被销毁；
</strong>weak表示变量指针是弱指针，如果没有其他强指针指向这个对象时，这个对象就会被销毁，同时弱指针会置为nil；
<strong>unsafe_unretained和</strong>weak类似，除了在对象销毁后不会使这个<strong>unsafe_unretained指针置为nil，因此这个指针就变成悬空指针！
</strong>autoreleasing用于传递给方法的参数是引用传值，并且在返回时会autorelease。
正确的关键字写法：</p>

<p><code>
MyClass * __weak weakReference;
MyClass * __unsafe_unretained unsafeReference;
</code></p>

<p>7)  避免循环引用问题
循环引用问题一般在两个类对象相互引用和使用Block对象时出现，解决两个类对象相互引用问题，可以将其中一个引用声明为弱引用，就可以打破循环引用问题。
Block对象常见的循环引用问题如下：</p>

<p>```
MyViewController *myController = [[MyViewController alloc] init…];</p>

<p>myController.completionBlock= ^() {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil]; }; 
</code></pre>

<p>```
上面例子中会导致completionBlock和myController循环引用，正确的处理方法有两种：</p>

<ul>
<li>一是使用<strong>block关键字，之后将该</strong>block变量置为nil</li>
</ul>


<p>```
MyViewController * __block myController = [[MyViewController alloc] init…];</p>

<p>myController.completionBlock= ^() {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil]; 
myController = nil;
</code></pre>

<p>};
```</p>

<ul>
<li>二是使用__weak关键字</li>
</ul>


<p>```
MyViewController * <strong>block myController = [[MyViewController alloc] init…];
MyViewController * </strong>weak weakMyViewController = myController;</p>

<p>myController.completionBlock= ^() {</p>

<pre><code>[weakMyViewController dismissViewControllerAnimated:YES completion:nil]; 
</code></pre>

<p>};
```</p>

<p>8)  toll-free bridge问题</p>

<p>对于要使用Core Foundation的对象时，要注意对象生命周期的所有权问题，重点是三个关键字<strong>bridge, </strong>bridge_retained和__bridge_trasfer对CF对象和NS对象的转换，使用方法参见上节工程转换时候的说明。</p>

<p>9)  ARC时所有临时变量指针(栈内生成)都会初始化为nil。例如：</p>

<p>```
- (void)test {</p>

<pre><code>NSString *name; 
NSLog(@"name: %@", name); 
</code></pre>

<p>}
```
上面代码会打印nil。</p>

<p>10) 如果有需要ARC管理的文件，可以在Xcode中设置工程Target的Build Phase中Compiler Source，不需要ARC管理的文件添加编译参数“-fno-objc-arc”。
<img src="/images/post/xcode-fno-objc-arc.jpg"></p>

<p>11) 在MRC情况下NSString * <strong>block myString是不会被retain的，但是ARC情况下NSString * </strong>block myString实际会被retian，如果需要和MRC下同样的语义，请使用：<strong>block NSString * </strong>unsafe_unretained myString 或者<strong>block NSString * </strong>weak myString。</p>

<p>12) iOS 4.*系统不支持weak语义，可以使用unsafe_unretained替代，但是可能导致悬空指针问题，需要小心对待。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于+initialize和+load的坑]]></title>
    <link href="http://hrchen.com/2013/07/tricky-initialize-and-load/"/>
    <updated>2013-07-03T22:29:00+08:00</updated>
    <id>http://hrchen.com/2013/07/tricky-initialize-and-load</id>
    <content type="html"><![CDATA[<p>NSObject有两个特殊的类方法+initialize和+load。+initialize会在类的任何其他函数调用前被调用，因此也可以利用这个特性实现Singleton单例：</p>

<p>```
static Manager +theManager = nil;</p>

<ul>
<li><p>(void) initialize
{
  if (self == [Manager class])
  {
      theManager = [[Manager alloc] init];
  }
}</p></li>
<li><p>(Manager *)sharedObj
{
return theManager;
}
```</p></li>
</ul>


<p>+load方法是在所在类加载到系统的时候被调用，这通常会比+initialized调用的时机要早，不过通常由于运行环境还有太多不确定性，不建议在+load中调用实际的方法。虽然Apple文档里说+initialized和+load都只会被执行一次，但是这里有坑。</p>

<p>如果子类里没有实现+initialized而父类里面实现了+initialized，那么用到子类时，不是说一定要生成对象，+initialize是调用任何方法，包括类方法，例如[SubClass class]，那么父类的+initialized就会被执行两次！解决办法也很简单，就像开头的写法<code>if (self == [Manager class])</code>，先判断下是不是当前类的类型。</p>

<p>那么对于+load呢？如果你在类的实现中实现了+load，但是在这个类的Category中又实现了一个+load，那么这两个+load都会被调用。</p>

<p>既然这两个方法都是如此的诡异，所以除非必要，最好都不要在这两个方法中执行太多的操作，尤其是+load。绕过坑，远离危险。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程Part 3/3 - GCD]]></title>
    <link href="http://hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/"/>
    <updated>2013-07-02T21:20:00+08:00</updated>
    <id>http://hrchen.com/2013/07/multi-threading-programming-of-ios-part-3</id>
    <content type="html"><![CDATA[<p>前两部分介绍了NSThread、NSRunLoop和NSOperation的基本支持，本文聊聊iOS4发布时推出的神器GCD。</p>

<h3>前言</h3>

<p>GCD: Grand Central Dispatch，是一组用于实现并发编程的C接口。GCD是完全基于Objective-C的Block特性开发的，基本调用逻辑和NSOperation很像，都是将工作添加到一个队列，由系统来负责线程的生成和调度。由于是直接使用Block，因此比NSOperation更加方便，大大降低了多线程开发的门槛。示例：</p>

<p>```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>[self doTask];
NSLog(@"Fisinished");
</code></pre>

<p>});
```</p>

<p>另外，GCD是开源的喔：<a href="http://libdispatch.macosforge.org/">libdispatch</a></p>

<h3>Dispatch Queue</h3>

<p>要添加工作到队列Dispatch Queue中，这个队列可以是串行或者并行的，并行队列会尽可能的并发执行其中的工作任务，而串行队列每次只能运行一个工作任务。</p>

<!--more-->


<p>目前GCD中有三种类型的Dispatch Queue：</p>

<ul>
<li>Main Queue：关联到主线程的队列，可以使用函数dispatch_get_main_queue()获得，加到这个队列中的工作都会分发到主线程运行。主线程只有一个，因此很明显这个是串行队列，每次运行一个工作。</li>
<li>Global Queue：全局队列是并发队列，又根据优先级细分为高优先级、默认优先级和低优先级三种。通过dispatch_get_global_queue加上优先级参数获得这个全局队列，例如<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code></li>
<li>自定义Queue：自己创建一个队列，只能是串行队列，可以理解为最终有一个独立的子线程帮你运行添加到这个队列中的工作任务。通过函数dispatch_queue_create创建，例如<code>dispatch_queue_create(@"com.kiloapp.test", 0)</code> ,第二个参数仅作保留，目前没有意义，第一个参数是队列的名字，Apple建议使用反DNS型的名字命名，防止重名。</li>
</ul>


<h3>添加工作任务</h3>

<p>添加工作任务到队列也非常简单，调用函数dispatch_async()，两个参数，一个就是Dispatch Queue，另一个是一个包含工作的Block，就像本文开头的示例一样。dispatch_async函数是非阻塞的，调用后会立刻返回，工作由系统分配线程去执行工作。因此另一种常见的使用模式是：</p>

<p>```
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{</p>

<pre><code>[self doHardWorkInBackground];
dispatch_async(dispatch_get_main_queue(), ^{
    [self updateUI];
});
</code></pre>

<p>});
```
可以将一些耗时的工作添加到全局队列，让系统分配线程在后台中去做，完成后，再次调用GCD的主队列去完成UI相关的工作，这样做就不会因为大量的非UI相关工作加重主线程负担，加快UI事件响应。</p>

<p>与dispatch_async对应的有一个dispatch_sync方法，它是阻塞式的，会一直等到添加的工作完成后才会返回。</p>

<p>NSOperation是没法直接使用的，它只是提供了一个工作的基本逻辑，具体实现还是需要你通过定义自己的NSOperation子类来获得。如果有必要也可以不将NSOperation加入到一个NSOperationQueue中去执行，直接调用起<code>-start</code>也可以直接执行。</p>

<h3>Dispatch Group</h3>

<p>GCD确实非常简单好用，不过有些情况还是有点问题，例如：</p>

<p>```
for(id obj in array)
{</p>

<pre><code>[self doWorkOnItem:obj];
</code></pre>

<p>}
[self doWorkOnArray:array];
```</p>

<p>前半部分可以用GCD得到处理性能的提升：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
for(id obj in array)</p>

<pre><code>dispatch_async(queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>[self doWorkOnArray:array];
<code>``
问题是</code>[self doWorkOnArray:array];<code>原先是在全部数组各个成员的工作完成后才会执行的，现在由于dispatch_async是非阻塞的，</code>[self doWorkOnArray:array];`很有可能在各个成员的工作完成前就运行了，这明显不符合我们的目的。如果将dispatch_async改成dispatch_sync可以解决问题，但是和原来的方法一样失去了并行的好处，也没有意义了。</p>

<p>针对这种情况，GCD提供了Dispatch Group可以将一组工作集合在一起，等待这组工作完成后再继续运行。dispatch_group_create函数可以用来创建这个Group：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(id obj in array)</p>

<pre><code>dispatch_group_async(group, queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
[self doWorkOnArray:array];
```</p>

<p>方法是不是很简单，将并发的工作用dispatch_group_async添加到一个Group和全局队列中，dispatch_group_wait会等待这些工作完成后再返回，这样你就可以再运行<code>[self doWorkOnArray:array];</code>。</p>

<p>不过有点不好的是dispatch_group_wait会阻塞当前线程，如果当前是主线程岂不是不好，有更绝的：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(id obj in array)</p>

<pre><code>dispatch_group_async(group, queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>dispatch_group_notify(group, queue, ^{</p>

<pre><code>[self doWorkOnArray:array];
</code></pre>

<p>});
dispatch_release(group);
```
dispatch_group_notify函数可以将这个Group完成后的工作也同样添加到队列中（如果是需要更新UI，这个队列也可以是主队列），总之这样做就完全不会阻塞当前线程了。</p>

<p>如果就是要同步的执行对数组元素的逐个操作，GCD也提供了一个简便的dispatch_apply函数：</p>

<p>```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply([array count], queue, ^(size_t index){</p>

<pre><code>[self doWorkOnItem:obj:[array objectAtIndex:index]];
</code></pre>

<p>});
[self doWorkOnArray:array];
```</p>

<p>要了解更全的接口，查看《Grand Central Dispatch (GCD) Reference》。</p>

<h3>其他有趣的特性</h3>

<ul>
<li>Dispatch Source</li>
</ul>


<p>Run Loop有Input Source，GCD也同样支持一系列事件，就是监听事件发生后会执行一个Block形式的Handler。Dispatch Source支持的事件源类型有：Timer源、signal信号源、描述符(文件或者网络描述符)源、进程源、Port源、自定义源。当然有些源由于iOS系统原因肯定是无法使用的，例如进程源、Port源、、signal信号源。</p>

<p>举个自定义源的例子，假如我们在处理上面那个数组时要在UI中显示一个进度条：</p>

<p>```
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());</p>

<p>dispatch_source_set_event_handler(source, ^{</p>

<pre><code>[progressIndicator incrementBy:dispatch_source_get_data(source)];
</code></pre>

<p>});
dispatch_resume(source);</p>

<p>dispatch_apply([array count], globalQueue, ^(size_t index) {</p>

<pre><code>[self doWorkOnItem:obj:[array objectAtIndex:index]];
dispatch_source_merge_data(source, 1);
</code></pre>

<p>});
```
dispatch source创建后是出于suspend状态的，必须使用dispatch_resume来恢复，dispatch_apply中每处理一个数组元素会调用dispatch_source_merge_data加1，那么这个source的事件handler就可以通过dispatch_source_get_data拿到source的数据。</p>

<ul>
<li>单例</li>
</ul>


<p>传统我们实现单例是这样：</p>

<p>```
+ (id)sharedManager
{</p>

<pre><code>static Manager *theManager = nil;
@synchronized([Manager class])
{
    if(!theManager)
        theManager = [[Manager alloc] init];
}
return theManager;
</code></pre>

<p>}</p>

<p>```
这个的成本还是有点高，每次访问都会有同步锁，而GCD有个dispatch_once方法(类似于<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_once.html">pthread_once</a>)可以保证只运行一次初始化：</p>

<p>```
+ (id)sharedWhatever
{</p>

<pre><code>static dispatch_once_t pred;
static Manager *theManager = nil;
dispatch_once(&amp;pred, ^{
    theManager = [[Manager alloc] init];
});
return theManager;
</code></pre>

<p>}
```</p>

<ul>
<li>信号量Semaphore</li>
</ul>


<p>和其他多线程技术一样，GCD也支持信号量，dispatch_semaphore_create用于创建，dispatch_semaphore_signal用于通知，dispatch_semaphore_wait用于等待。</p>

<h3>参考资料</h3>

<p><a href="https://developer.apple.com/library/mac/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html">Grand Central Dispatch (GCD) Reference</a></p>

<p><a href="https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html">Blocks Programming Topics</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个NSURLConnectionDelegate的坑]]></title>
    <link href="http://hrchen.com/2013/06/tricky-nsurlconnectiondelegate/"/>
    <updated>2013-06-30T04:20:00+08:00</updated>
    <id>http://hrchen.com/2013/06/tricky-nsurlconnectiondelegate</id>
    <content type="html"><![CDATA[<p>NSURLConnection的坑还是蛮多的，上次是<a href="http://www.hrchen.com/2013/06/nsurlconnection-with-nsrunloopcommonmodes/">RunLoopMode的问题</a>，这次是关于NSURLConnectionDelegate。</p>

<p>NSURLConnection的代理Protocol定义有三类：NSURLConnectionDelegate、NSURLConnectionDataDelegate和NSURLConnectionDownloadDelegate。</p>

<ul>
<li>NSURLConnectionDelegate：所有类型NSURLConnection的基础代理方法，都是Optional的方法，主要是涉及SSL/TSL加密的相关接口。</li>
</ul>


<p>```
@optional
- (void)connection:(NSURLConnection <em>)connection didFailWithError:(NSError </em>)error;
- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection <em>)connection;
- (void)connection:(NSURLConnection </em>)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;</p>

<p>```
* NSURLConnectionDataDelegate：用于将网络请求的数据存放到内存中(以NSData的形式)的代理方法。所有方法都是Optional的。</p>

<!--more-->


<p>```
@optional
- (NSURLRequest <em>)connection:(NSURLConnection </em>)connection willSendRequest:(NSURLRequest <em>)request redirectResponse:(NSURLResponse </em>)response;
- (void)connection:(NSURLConnection <em>)connection didReceiveResponse:(NSURLResponse </em>)response;</p>

<ul>
<li><p>(void)connection:(NSURLConnection <em>)connection didReceiveData:(NSData </em>)data;</p></li>
<li><p>(NSInputStream <em>)connection:(NSURLConnection </em>)connection needNewBodyStream:(NSURLRequest *)request;</p></li>
<li><p>(void)connection:(NSURLConnection *)connection   didSendBodyData:(NSInteger)bytesWritten
                                               totalBytesWritten:(NSInteger)totalBytesWritten
                                       totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite;</p></li>
<li><p>(NSCachedURLResponse <em>)connection:(NSURLConnection </em>)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;</p></li>
<li><p>(void)connectionDidFinishLoading:(NSURLConnection *)connection;</p></li>
</ul>


<p>```
* NSURLConnectionDownloadDelegate：用于将网络资源直接保存到文件中的代理方法，除了connectionDidFinishDownloading:destinationURL:都是Optional的方法。connectionDidFinishDownloading:destinationURL回调可以告知你下载的网络数据最终存放的文件位置，正常都是在iPhone应用沙盒的/tmp目录下。</p>

<p>```
@optional
- (void)connection:(NSURLConnection <em>)connection didWriteData:(long long)bytesWritten totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes;
- (void)connectionDidResumeDownloading:(NSURLConnection </em>)connection totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes;</p>

<p>@required
- (void)connectionDidFinishDownloading:(NSURLConnection <em>)connection destinationURL:(NSURL </em>) destinationURL;</p>

<p>```</p>

<p>由于生成NSURLConnectin对象传入delegate参数时类型就是id，而不是传统id&lt;***Delegate>形式，那么如何确定当前代理实现的是什么类型的NSURLConnectionDelegate代理呢？方法也很诡异，如果你的代理实现了connectionDidFinishDownloading:destinationURL:，那么就表示你要实现的是NSURLConnectionDownloadDelegate，NSURLConnectionDataDelegate中的connection:DidReceiveData就不会得到回调，即使你实现了它。道理很简单，这两类代理一个是用于将下载数据保存到文件上，另一个是保存到内存中，只能两者居其一。</p>

<p>故事还没有结束 ，如果你实现了connectionDidFinishDownloading:destinationURL并且想通过回到得到的destinationURL读取保存数据的文件时，令人惊讶的发现这个文件居然不存在，因为这类NSURLConnectionDataDelegate回调是用于Newsstand类型的App开发的，用于将杂志等信息保存到本地文件。实在想不通为什么只有Newsstand类型App才能用这组接口，很多开发者早已发了bug报告给Apple，Apple也已经确认，但是从iOS5到了iOS7，这个“bug”还是没有被修复。</p>

<p>附带我在Stackoverflow上的<a href="http://stackoverflow.com/questions/11047169/how-may-delegate-method-from-one-protocol-prevent-execution-of-another-one-from/17369617#17369617">回答</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程Part 2/3 - NSOperation]]></title>
    <link href="http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-2/"/>
    <updated>2013-06-28T23:59:00+08:00</updated>
    <id>http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-2</id>
    <content type="html"><![CDATA[<p>多线程编程Part 1介绍了NSThread以及NSRunLoop，这篇Blog介绍另一种并发编程技术：NSOPeration。</p>

<h3>NSOperation &amp; NSOperationQueue</h3>

<p>从头文件NSOperation.h来看接口是非常的简洁，NSOperation本身是一个抽象类，定义了一个要执行的工作，NSOperationQueue是一个工作队列，当工作加入到队列后，NSOperationQueue会自动按照优先顺序及工作的从属依赖关系(如果有的话)组织执行。</p>

<p>NSOperation是没法直接使用的，它只是提供了一个工作的基本逻辑，具体实现还是需要你通过定义自己的NSOperation子类来获得。如果有必要也可以不将NSOperation加入到一个NSOperationQueue中去执行，直接调用起<code>-start</code>也可以直接执行。</p>

<!--more-->


<p>在继承NSOpertaion后，对于非并发的工作，只需要实现NSOperation子类的main方法：</p>

<p>```
-(void)main
{
   @try
   {</p>

<pre><code>  // 处理工作任务
</code></pre>

<p>   }
   @catch(...)
   {</p>

<pre><code>  // 处理异常，但是不能再重新抛出异常
</code></pre>

<p>   }
}
<code>``
由于NSOperation的工作是可以取消Cancel的，那么你在main方法处理工作时就需要不断轮询</code>[self isCancelled]`确认当前的工作是否被取消了。</p>

<p>如果要支持并发工作，那么NSOperation子类需要至少override这四个方法:</p>

<ul>
<li>start</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
</ul>


<p>实现了一个基于Operation的下载器，在Sample Code中可以下载。</p>

<p>```
- (void)operationDidStart
{</p>

<pre><code>[self.lock lock];
NSMutableURLRequest* request = [[NSMutableURLRequest alloc] initWithURL:self.URL
                                                            cachePolicy:NSURLRequestReloadIgnoringCacheData
                                                        timeoutInterval:self.timeoutInterval];
[request setHTTPMethod: @"GET"];

self.connection =[[NSURLConnection alloc] initWithRequest:request
                                                 delegate:self
                                         startImmediately:NO];
[self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
[self.connection start];
[self.lock unlock];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)operationDidFinish
{
  [self.lock lock];
  [self willChangeValueForKey:@"isFinished"];
  [self willChangeValueForKey:@"isExecuting"];</p>

<p>  self.executing = NO;
  self.finished = YES;</p>

<p>  [self didChangeValueForKey:@"isExecuting"];
  [self didChangeValueForKey:@"isFinished"];
  [self.lock unlock];
}</p></li>
<li><p>(void)start
{
  [self.lock lock];
  if ([self isCancelled])
  {
      [self willChangeValueForKey:@"isFinished"];
      self.finished = YES;
      [self didChangeValueForKey:@"isFinished"];
      return;
  }</p>

<p>  [self willChangeValueForKey:@"isExecuting"];
  [self performSelector:@selector(operationDidStart) onThread:[[self class] networkThread] withObject:nil waitUntilDone:NO];
  self.executing = YES;
  [self didChangeValueForKey:@"isExecuting"];
  [self.lock unlock];
}</p></li>
<li><p>(void)cancel
{
  [self.lock lock];
  [super cancel];
  if (self.connection)
  {
      [self.connection cancel];
      self.connection = nil;
  }</p>

<p>  [self.lock unlock];
}</p></li>
<li><p>(BOOL)isConcurrent {
  return YES;
}</p></li>
<li><p>(BOOL)isExecuting {
  return self.executing;
}</p></li>
<li><p>(BOOL)isFinished {
  return self.finished;
}</p></li>
</ul>


<p>```</p>

<p>start方法是工作的入口，通常是你用来设置线程或者其他执行工作任务需要的运行环境的，注意不要调用[super start]；isConcurrent是标识这个Operation是否是并发执行的，这里是个坑，如果你没有实现isConcurrent，默认是返回NO，那么你的NSOperation就不是并发执行而是串行执行的，大多数情况下这可不是你想要的；isExecuting和isFinished是用来报告当前的工作执行状态情况的，注意必须是线程访问安全的。</p>

<p>注意你的实现要发出合适的KVO通知，因为如果你的NSOperation实现需要用到工作依赖从属特性，而你的实现里没有发出合适的“isFinished”KVO通知，依赖你的NSOperation就无法正常执行。NSOperation有许多支持KVO的属性：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<p>当然也不是说所有的KVO通知都需要自己去实现，例如通常你用不到addObserver到你工作的“isCancelled”属性，你只需要直接调用cancel方法就可以取消这个工作任务。</p>

<p>实现NSOperation子类后，可以直接调用start或者添加到一个NSOperationQueue里：</p>

<p>```
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperation:downloader];</p>

<p>```</p>

<h3>NSOperation和NSOperationQueue其他特性</h3>

<p>工作是有优先级的，可以通过NSOperation的一下两个接口读取或者设置：</p>

<p><code>
- (NSOperationQueuePriority)queuePriority;
- (void)setQueuePriority:(NSOperationQueuePriority)p;
</code></p>

<p>工作之间也可有从属依赖关系，只有依赖的工作完成后才会执行：</p>

<p><code>
- (void)addDependency:(NSOperation *)op;
- (void)removeDependency:(NSOperation *)op;
</code></p>

<p>还可以通过下面接口设置运行NSOpration的子线程优先级：</p>

<p><code>
- (void)setQueuePriority:(NSOperationQueuePriority)priority;
</code></p>

<p>iOS4之后还可以往NSOperation上添加一个结束block，用于在工作执行结束之后的操作：</p>

<p><code>
- (void)setCompletionBlock:(void (^)(void))block;
</code></p>

<p>如果需要阻塞等待NSOperation工作结束(别在主线程这么干)，可以使用接口：</p>

<p><code>
- (void)waitUntilFinished;
</code></p>

<p>NSOperationQueue除了添加NSOperation外，也支持直接添加一个Block(iOS4之后)：</p>

<p><code>
- (void)addOperationWithBlock:(void (^)(void))block
</code></p>

<p>NSOperationQueue可以取消所有添加的工作：</p>

<p><code>
- (void)cancelAllOperations;
</code>
也可以阻塞式的等待所有工作结束(别在主线程这么干)：</p>

<p><code>
- (void)waitUntilAllOperationsAreFinished;
</code></p>

<p>在NSOperation对象中获得被添加的NSOperationQueue队列：</p>

<p><code>
+ (id)currentQueue
</code></p>

<p>要获得一个绑定在主线程的NSOperationQueue队列：</p>

<p><code>
+ (id)mainQueue
</code></p>

<h3>NSInvocationOperation &amp; NSBlockOperation</h3>

<p>其实除非必要，简单的工作完全可以使用官方提供的NSOperation两个子类NSInvocationOperation和NSBlockOperation来实现。</p>

<p>NSInvocationOperation：</p>

<p>```
NSInvocationOperation* theOp = [[NSInvocationOperation alloc]</p>

<pre><code>                   initWithTarget:self                 
                      selector:@selector(myTaskMethod:)                                           
                        object:data];
</code></pre>

<p>```</p>

<p>NSBlockOperation:</p>

<p>```
NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{</p>

<pre><code>  NSLog(@"Beginning operation.\n");
  // Do some work.
</code></pre>

<p>   }];
```</p>

<p>接口非常简单，一看便会。</p>

<h3>Sample Code</h3>

<p>本文例子放在<a href="https://github.com/hrchen/ExamplesForBlog">Github</a>上（工程NSURLConnectionExample中的PTOperationDownloader）。</p>

<h3>参考资料</h3>

<p><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html">Concurrency Programming Guide</a></p>

<p><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html">NSOperation Class Reference</a></p>
]]></content>
  </entry>
  
</feed>
