<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hrchen's blogging]]></title>
  <link href="http://hrchen.com/atom.xml" rel="self"/>
  <link href="http://hrchen.com/"/>
  <updated>2013-07-07T22:51:35+08:00</updated>
  <id>http://hrchen.com/</id>
  <author>
    <name><![CDATA[hrchen]]></name>
    <email><![CDATA[dr.hrchen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于+initialize和+load的坑]]></title>
    <link href="http://hrchen.com/2013/07/tricky-initialize-and-load/"/>
    <updated>2013-07-03T22:29:00+08:00</updated>
    <id>http://hrchen.com/2013/07/tricky-initialize-and-load</id>
    <content type="html"><![CDATA[<p>NSObject有两个特殊的类方法+initialize和+load。+initialize会在类的任何其他函数调用前被调用，因此也可以利用这个特性实现Singleton单例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static Manager +theManager = nil;
</span><span class='line'>
</span><span class='line'>+ (void) initialize 
</span><span class='line'>{
</span><span class='line'>  if (self == [Manager class]) 
</span><span class='line'>  {
</span><span class='line'>      theManager = [[Manager alloc] init];
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (Manager *)sharedObj 
</span><span class='line'>{
</span><span class='line'>  return theManager;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>+load方法是在所在类加载到系统的时候被调用，这通常会比+initialized调用的时机要早，不过通常由于运行环境还有太多不确定性，不建议在+load中调用实际的方法。虽然Apple文档里说+initialized和+load都只会被执行一次，但是这里有坑。</p>

<p>如果子类里没有实现+initialized而父类里面实现了+initialized，那么用到子类时，不是说一定要生成对象，+initialize是调用任何方法，包括类方法，例如[SubClass class]，那么父类的+initialized就会被执行两次！解决办法也很简单，就像开头的写法<code>if (self == [Manager class])</code>，先判断下是不是当前类的类型。</p>

<p>那么对于+load呢？如果你在类的实现中实现了+load，但是在这个类的Category中又实现了一个+load，那么这两个+load都会被调用。</p>

<p>既然这两个方法都是如此的诡异，所以除非必要，最好都不要在这两个方法中执行太多的操作，尤其是+load。绕过坑，远离危险。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程Part 3/3 - GCD]]></title>
    <link href="http://hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/"/>
    <updated>2013-07-02T21:20:00+08:00</updated>
    <id>http://hrchen.com/2013/07/multi-threading-programming-of-ios-part-3</id>
    <content type="html"><![CDATA[<p>前两部分介绍了NSThread、NSRunLoop和NSOperation的基本支持，本文聊聊iOS4发布时推出的神器GCD。</p>

<h3>前言</h3>

<p>GCD: Grand Central Dispatch，是一组用于实现并发编程的C接口。GCD是完全基于Objective-C的Block特性开发的，基本调用逻辑和NSOperation很像，都是将工作添加到一个队列，由系统来负责线程的生成和调度。由于是直接使用Block，因此比NSOperation更加方便，大大降低了多线程开发的门槛。示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
</span><span class='line'>    [self doTask];
</span><span class='line'>    NSLog(@"Fisinished");
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>另外，GCD是开源的喔：<a href="http://libdispatch.macosforge.org/">libdispatch</a></p>

<h3>Dispatch Queue</h3>

<p>要添加工作到队列Dispatch Queue中，这个队列可以是串行或者并行的，并行队列会尽可能的并发执行其中的工作任务，而串行队列每次只能运行一个工作任务。</p>

<!--more-->


<p>目前GCD中有三种类型的Dispatch Queue：</p>

<ul>
<li>Main Queue：关联到主线程的队列，可以使用函数dispatch_get_main_queue()获得，加到这个队列中的工作都会分发到主线程运行。主线程只有一个，因此很明显这个是串行队列，每次运行一个工作。</li>
<li>Global Queue：全局队列是并发队列，又根据优先级细分为高优先级、默认优先级和低优先级三种。通过dispatch_get_global_queue加上优先级参数获得这个全局队列，例如<code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code></li>
<li>自定义Queue：自己创建一个队列，只能是串行队列，可以理解为最终有一个独立的子线程帮你运行添加到这个队列中的工作任务。通过函数dispatch_queue_create创建，例如<code>dispatch_queue_create(@"com.kiloapp.test", 0)</code> ,第二个参数仅作保留，目前没有意义，第一个参数是队列的名字，Apple建议使用反DNS型的名字命名，防止重名。</li>
</ul>


<h3>添加工作任务</h3>

<p>添加工作任务到队列也非常简单，调用函数dispatch_async()，两个参数，一个就是Dispatch Queue，另一个是一个包含工作的Block，就像本文开头的示例一样。dispatch_async函数是非阻塞的，调用后会立刻返回，工作由系统分配线程去执行工作。因此另一种常见的使用模式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
</span><span class='line'>    [self doHardWorkInBackground];
</span><span class='line'>    dispatch_async(dispatch_get_main_queue(), ^{
</span><span class='line'>        [self updateUI];
</span><span class='line'>    });
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>可以将一些耗时的工作添加到全局队列，让系统分配线程在后台中去做，完成后，再次调用GCD的主队列去完成UI相关的工作，这样做就不会因为大量的非UI相关工作加重主线程负担，加快UI事件响应。</p>

<p>与dispatch_async对应的有一个dispatch_sync方法，它是阻塞式的，会一直等到添加的工作完成后才会返回。</p>

<p>NSOperation是没法直接使用的，它只是提供了一个工作的基本逻辑，具体实现还是需要你通过定义自己的NSOperation子类来获得。如果有必要也可以不将NSOperation加入到一个NSOperationQueue中去执行，直接调用起<code>-start</code>也可以直接执行。</p>

<h3>Dispatch Group</h3>

<p>GCD确实非常简单好用，不过有些情况还是有点问题，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(id obj in array)
</span><span class='line'>{
</span><span class='line'>    [self doWorkOnItem:obj];
</span><span class='line'>}
</span><span class='line'>[self doWorkOnArray:array];</span></code></pre></td></tr></table></div></figure>


<p>前半部分可以用GCD得到处理性能的提升：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class='line'>for(id obj in array)
</span><span class='line'>    dispatch_async(queue, ^{
</span><span class='line'>        [self doWorkOnItem:obj];
</span><span class='line'>    });
</span><span class='line'>[self doWorkOnArray:array];</span></code></pre></td></tr></table></div></figure>


<p>问题是<code>[self doWorkOnArray:array];</code>原先是在全部数组各个成员的工作完成后才会执行的，现在由于dispatch_async是非阻塞的，<code>[self doWorkOnArray:array];</code>很有可能在各个成员的工作完成前就运行了，这明显不符合我们的目的。如果将dispatch_async改成dispatch_sync可以解决问题，但是和原来的方法一样失去了并行的好处，也没有意义了。</p>

<p>针对这种情况，GCD提供了Dispatch Group可以将一组工作集合在一起，等待这组工作完成后再继续运行。dispatch_group_create函数可以用来创建这个Group：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class='line'>dispatch_group_t group = dispatch_group_create();
</span><span class='line'>for(id obj in array)
</span><span class='line'>    dispatch_group_async(group, queue, ^{
</span><span class='line'>        [self doWorkOnItem:obj];
</span><span class='line'>    });
</span><span class='line'>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
</span><span class='line'>dispatch_release(group);
</span><span class='line'>[self doWorkOnArray:array];</span></code></pre></td></tr></table></div></figure>


<p>方法是不是很简单，将并发的工作用dispatch_group_async添加到一个Group和全局队列中，dispatch_group_wait会等待这些工作完成后再返回，这样你就可以再运行<code>[self doWorkOnArray:array];</code>。</p>

<p>不过有点不好的是dispatch_group_wait会阻塞当前线程，如果当前是主线程岂不是不好，有更绝的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class='line'>dispatch_group_t group = dispatch_group_create();
</span><span class='line'>for(id obj in array)
</span><span class='line'>    dispatch_group_async(group, queue, ^{
</span><span class='line'>        [self doWorkOnItem:obj];
</span><span class='line'>    });
</span><span class='line'>dispatch_group_notify(group, queue, ^{
</span><span class='line'>    [self doWorkOnArray:array];
</span><span class='line'>});
</span><span class='line'>dispatch_release(group);</span></code></pre></td></tr></table></div></figure>


<p>dispatch_group_notify函数可以将这个Group完成后的工作也同样添加到队列中（如果是需要更新UI，这个队列也可以是主队列），总之这样做就完全不会阻塞当前线程了。</p>

<p>如果就是要同步的执行对数组元素的逐个操作，GCD也提供了一个简便的dispatch_apply函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</span><span class='line'>dispatch_apply([array count], queue, ^(size_t index){
</span><span class='line'>    [self doWorkOnItem:obj:[array objectAtIndex:index]];
</span><span class='line'>});
</span><span class='line'>[self doWorkOnArray:array];</span></code></pre></td></tr></table></div></figure>


<p>要了解更全的接口，查看《Grand Central Dispatch (GCD) Reference》。</p>

<h3>其他有趣的特性</h3>

<ul>
<li>Dispatch Source</li>
</ul>


<p>Run Loop有Input Source，GCD也同样支持一系列事件，就是监听事件发生后会执行一个Block形式的Handler。Dispatch Source支持的事件源类型有：Timer源、signal信号源、描述符(文件或者网络描述符)源、进程源、Port源、自定义源。当然有些源由于iOS系统原因肯定是无法使用的，例如进程源、Port源、、signal信号源。</p>

<p>举个自定义源的例子，假如我们在处理上面那个数组时要在UI中显示一个进度条：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());
</span><span class='line'>
</span><span class='line'>dispatch_source_set_event_handler(source, ^{
</span><span class='line'>    [progressIndicator incrementBy:dispatch_source_get_data(source)];
</span><span class='line'>});
</span><span class='line'>dispatch_resume(source);
</span><span class='line'>    
</span><span class='line'>dispatch_apply([array count], globalQueue, ^(size_t index) {
</span><span class='line'>    [self doWorkOnItem:obj:[array objectAtIndex:index]];
</span><span class='line'>    dispatch_source_merge_data(source, 1);
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>dispatch source创建后是出于suspend状态的，必须使用dispatch_resume来恢复，dispatch_apply中每处理一个数组元素会调用dispatch_source_merge_data加1，那么这个source的事件handler就可以通过dispatch_source_get_data拿到source的数据。</p>

<ul>
<li>单例</li>
</ul>


<p>传统我们实现单例是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (id)sharedManager
</span><span class='line'>{
</span><span class='line'>    static Manager *theManager = nil;
</span><span class='line'>    @synchronized([Manager class])
</span><span class='line'>    {
</span><span class='line'>        if(!theManager)
</span><span class='line'>            theManager = [[Manager alloc] init];
</span><span class='line'>    }
</span><span class='line'>    return theManager;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>这个的成本还是有点高，每次访问都会有同步锁，而GCD有个dispatch_once方法(类似于<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_once.html">pthread_once</a>)可以保证只运行一次初始化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (id)sharedWhatever
</span><span class='line'>{
</span><span class='line'>    static dispatch_once_t pred;
</span><span class='line'>    static Manager *theManager = nil;
</span><span class='line'>    dispatch_once(&pred, ^{
</span><span class='line'>        theManager = [[Manager alloc] init];
</span><span class='line'>    });
</span><span class='line'>    return theManager;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>信号量Semaphore</li>
</ul>


<p>和其他多线程技术一样，GCD也支持信号量，dispatch_semaphore_create用于创建，dispatch_semaphore_signal用于通知，dispatch_semaphore_wait用于等待。</p>

<h3>参考资料</h3>

<p><a href="https://developer.apple.com/library/mac/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html">Grand Central Dispatch (GCD) Reference</a></p>

<p><a href="https://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html">Blocks Programming Topics</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个NSURLConnectionDelegate的坑]]></title>
    <link href="http://hrchen.com/2013/06/tricky-nsurlconnectiondelegate/"/>
    <updated>2013-06-30T04:20:00+08:00</updated>
    <id>http://hrchen.com/2013/06/tricky-nsurlconnectiondelegate</id>
    <content type="html"><![CDATA[<p>NSURLConnection的坑还是蛮多的，上次是<a href="http://www.hrchen.com/2013/06/nsurlconnection-with-nsrunloopcommonmodes/">RunLoopMode的问题</a>，这次是关于NSURLConnectionDelegate。</p>

<p>NSURLConnection的代理Protocol定义有三类：NSURLConnectionDelegate、NSURLConnectionDataDelegate和NSURLConnectionDownloadDelegate。</p>

<ul>
<li>NSURLConnectionDelegate：所有类型NSURLConnection的基础代理方法，都是Optional的方法，主要是涉及SSL/TSL加密的相关接口。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@optional
</span><span class='line'>- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error;
</span><span class='line'>- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection;
</span><span class='line'>- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSURLConnectionDataDelegate：用于将网络请求的数据存放到内存中(以NSData的形式)的代理方法。所有方法都是Optional的。</li>
</ul>


<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@optional
</span><span class='line'>- (NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response;
</span><span class='line'>- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;
</span><span class='line'>
</span><span class='line'>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;
</span><span class='line'>
</span><span class='line'>- (NSInputStream *)connection:(NSURLConnection *)connection needNewBodyStream:(NSURLRequest *)request;
</span><span class='line'>- (void)connection:(NSURLConnection *)connection   didSendBodyData:(NSInteger)bytesWritten
</span><span class='line'>                                                 totalBytesWritten:(NSInteger)totalBytesWritten
</span><span class='line'>                                         totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite;
</span><span class='line'>
</span><span class='line'>- (NSCachedURLResponse *)connection:(NSURLConnection *)connection willCacheResponse:(NSCachedURLResponse *)cachedResponse;
</span><span class='line'>
</span><span class='line'>- (void)connectionDidFinishLoading:(NSURLConnection *)connection;
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>NSURLConnectionDownloadDelegate：用于将网络资源直接保存到文件中的代理方法，除了connectionDidFinishDownloading:destinationURL:都是Optional的方法。connectionDidFinishDownloading:destinationURL回调可以告知你下载的网络数据最终存放的文件位置，正常都是在iPhone应用沙盒的/tmp目录下。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@optional
</span><span class='line'>- (void)connection:(NSURLConnection *)connection didWriteData:(long long)bytesWritten totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes;
</span><span class='line'>- (void)connectionDidResumeDownloading:(NSURLConnection *)connection totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes;
</span><span class='line'>
</span><span class='line'>@required
</span><span class='line'>- (void)connectionDidFinishDownloading:(NSURLConnection *)connection destinationURL:(NSURL *) destinationURL;
</span></code></pre></td></tr></table></div></figure>


<p>由于生成NSURLConnectin对象传入delegate参数时类型就是id，而不是传统id&lt;***Delegate>形式，那么如何确定当前代理实现的是什么类型的NSURLConnectionDelegate代理呢？方法也很诡异，如果你的代理实现了connectionDidFinishDownloading:destinationURL:，那么就表示你要实现的是NSURLConnectionDownloadDelegate，NSURLConnectionDataDelegate中的connection:DidReceiveData就不会得到回调，即使你实现了它。道理很简单，这两类代理一个是用于将下载数据保存到文件上，另一个是保存到内存中，只能两者居其一。</p>

<p>故事还没有结束 ，如果你实现了connectionDidFinishDownloading:destinationURL并且想通过回到得到的destinationURL读取保存数据的文件时，令人惊讶的发现这个文件居然不存在，因为这类NSURLConnectionDataDelegate回调是用于Newsstand类型的App开发的，用于将杂志等信息保存到本地文件。实在想不通为什么只有Newsstand类型App才能用这组接口，很多开发者早已发了bug报告给Apple，Apple也已经确认，但是从iOS5到了iOS7，这个“bug”还是没有被修复。</p>

<p>附带我在Stackoverflow上的<a href="http://stackoverflow.com/questions/11047169/how-may-delegate-method-from-one-protocol-prevent-execution-of-another-one-from/17369617#17369617">回答</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程Part 2/3 - NSOperation]]></title>
    <link href="http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-2/"/>
    <updated>2013-06-28T23:59:00+08:00</updated>
    <id>http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-2</id>
    <content type="html"><![CDATA[<p>多线程编程Part 1介绍了NSThread以及NSRunLoop，这篇Blog介绍另一种并发编程技术：NSOPeration。</p>

<h3>NSOperation &amp; NSOperationQueue</h3>

<p>从头文件NSOperation.h来看接口是非常的简洁，NSOperation本身是一个抽象类，定义了一个要执行的工作，NSOperationQueue是一个工作队列，当工作加入到队列后，NSOperationQueue会自动按照优先顺序及工作的从属依赖关系(如果有的话)组织执行。</p>

<p>NSOperation是没法直接使用的，它只是提供了一个工作的基本逻辑，具体实现还是需要你通过定义自己的NSOperation子类来获得。如果有必要也可以不将NSOperation加入到一个NSOperationQueue中去执行，直接调用起<code>-start</code>也可以直接执行。</p>

<!--more-->


<p>在继承NSOpertaion后，对于非并发的工作，只需要实现NSOperation子类的main方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-(void)main 
</span><span class='line'>{
</span><span class='line'>   @try 
</span><span class='line'>   {
</span><span class='line'>      // 处理工作任务
</span><span class='line'>   }
</span><span class='line'>   @catch(...) 
</span><span class='line'>   {
</span><span class='line'>      // 处理异常，但是不能再重新抛出异常
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>由于NSOperation的工作是可以取消Cancel的，那么你在main方法处理工作时就需要不断轮询<code>[self isCancelled]</code>确认当前的工作是否被取消了。</p>

<p>如果要支持并发工作，那么NSOperation子类需要至少override这四个方法:</p>

<ul>
<li>start</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
</ul>


<p>实现了一个基于Operation的下载器，在Sample Code中可以下载。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)operationDidStart
</span><span class='line'>{
</span><span class='line'>    [self.lock lock];
</span><span class='line'>    NSMutableURLRequest* request = [[NSMutableURLRequest alloc] initWithURL:self.URL
</span><span class='line'>                                                                cachePolicy:NSURLRequestReloadIgnoringCacheData
</span><span class='line'>                                                            timeoutInterval:self.timeoutInterval];
</span><span class='line'>    [request setHTTPMethod: @"GET"];
</span><span class='line'>    
</span><span class='line'>    self.connection =[[NSURLConnection alloc] initWithRequest:request
</span><span class='line'>                                                     delegate:self
</span><span class='line'>                                             startImmediately:NO];
</span><span class='line'>    [self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
</span><span class='line'>    [self.connection start];
</span><span class='line'>    [self.lock unlock];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)operationDidFinish
</span><span class='line'>{
</span><span class='line'>    [self.lock lock];
</span><span class='line'>    [self willChangeValueForKey:@"isFinished"];
</span><span class='line'>    [self willChangeValueForKey:@"isExecuting"];
</span><span class='line'>    
</span><span class='line'>    self.executing = NO;
</span><span class='line'>    self.finished = YES;
</span><span class='line'>    
</span><span class='line'>    [self didChangeValueForKey:@"isExecuting"];
</span><span class='line'>    [self didChangeValueForKey:@"isFinished"];
</span><span class='line'>    [self.lock unlock];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)start
</span><span class='line'>{
</span><span class='line'>    [self.lock lock];
</span><span class='line'>    if ([self isCancelled])
</span><span class='line'>    {
</span><span class='line'>        [self willChangeValueForKey:@"isFinished"];
</span><span class='line'>        self.finished = YES;
</span><span class='line'>        [self didChangeValueForKey:@"isFinished"];
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    [self willChangeValueForKey:@"isExecuting"];
</span><span class='line'>    [self performSelector:@selector(operationDidStart) onThread:[[self class] networkThread] withObject:nil waitUntilDone:NO];
</span><span class='line'>    self.executing = YES;
</span><span class='line'>    [self didChangeValueForKey:@"isExecuting"];
</span><span class='line'>    [self.lock unlock];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)cancel
</span><span class='line'>{
</span><span class='line'>    [self.lock lock];
</span><span class='line'>    [super cancel];
</span><span class='line'>    if (self.connection)
</span><span class='line'>    {
</span><span class='line'>        [self.connection cancel];
</span><span class='line'>        self.connection = nil;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    [self.lock unlock];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (BOOL)isConcurrent {
</span><span class='line'>    return YES;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (BOOL)isExecuting {
</span><span class='line'>    return self.executing;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (BOOL)isFinished {
</span><span class='line'>    return self.finished;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>start方法是工作的入口，通常是你用来设置线程或者其他执行工作任务需要的运行环境的，注意不要调用[super start]；isConcurrent是标识这个Operation是否是并发执行的；isExecuting和isFinished是用来报告当前的工作执行状态情况的，注意必须是线程访问安全的。</p>

<p>注意你的实现要发出合适的KVO通知，因为如果你的NSOperation实现需要用到工作依赖从属特性，而你的实现里没有发出合适的“isFinished”KVO通知，依赖你的NSOperation就无法正常执行。NSOperation有许多支持KVO的属性：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<p>当然也不是说所有的KVO通知都需要自己去实现，例如通常你用不到addObserver到你工作的“isCancelled”属性，你只需要直接调用cancel方法就可以取消这个工作任务。</p>

<p>实现NSOperation子类后，可以直接调用start或者添加到一个NSOperationQueue里：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
</span><span class='line'>[queue addOperation:downloader];
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<h3>NSOperation和NSOperationQueue其他特性</h3>

<p>工作是有优先级的，可以通过NSOperation的一下两个接口读取或者设置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSOperationQueuePriority)queuePriority;
</span><span class='line'>- (void)setQueuePriority:(NSOperationQueuePriority)p;</span></code></pre></td></tr></table></div></figure>


<p>工作之间也可有从属依赖关系，只有依赖的工作完成后才会执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addDependency:(NSOperation *)op;
</span><span class='line'>- (void)removeDependency:(NSOperation *)op;</span></code></pre></td></tr></table></div></figure>


<p>还可以通过下面接口设置运行NSOpration的子线程优先级：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setQueuePriority:(NSOperationQueuePriority)priority;</span></code></pre></td></tr></table></div></figure>


<p>iOS4之后还可以往NSOperation上添加一个结束block，用于在工作执行结束之后的操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)setCompletionBlock:(void (^)(void))block;</span></code></pre></td></tr></table></div></figure>


<p>如果需要阻塞等待NSOperation工作结束(别在主线程这么干)，可以使用接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)waitUntilFinished;</span></code></pre></td></tr></table></div></figure>


<p>NSOperationQueue除了添加NSOperation外，也支持直接添加一个Block(iOS4之后)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)addOperationWithBlock:(void (^)(void))block</span></code></pre></td></tr></table></div></figure>


<p>NSOperationQueue可以取消所有添加的工作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)cancelAllOperations;</span></code></pre></td></tr></table></div></figure>


<p>也可以阻塞式的等待所有工作结束(别在主线程这么干)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)waitUntilAllOperationsAreFinished;</span></code></pre></td></tr></table></div></figure>


<p>在NSOperation对象中获得被添加的NSOperationQueue队列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (id)currentQueue</span></code></pre></td></tr></table></div></figure>


<p>要获得一个绑定在主线程的NSOperationQueue队列：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (id)mainQueue</span></code></pre></td></tr></table></div></figure>


<h3>NSInvocationOperation &amp; NSBlockOperation</h3>

<p>其实除非必要，简单的工作完全可以使用官方提供的NSOperation两个子类NSInvocationOperation和NSBlockOperation来实现。</p>

<p>NSInvocationOperation：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSInvocationOperation* theOp = [[NSInvocationOperation alloc] 
</span><span class='line'>                       initWithTarget:self                 
</span><span class='line'>                        selector:@selector(myTaskMethod:)                                           
</span><span class='line'>                            object:data];</span></code></pre></td></tr></table></div></figure>


<p>NSBlockOperation:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{
</span><span class='line'>      NSLog(@"Beginning operation.\n");
</span><span class='line'>      // Do some work.
</span><span class='line'>   }];</span></code></pre></td></tr></table></div></figure>


<p>接口非常简单，一看便会。</p>

<h3>Sample Code</h3>

<p>本文例子放在<a href="https://github.com/hrchen/ExamplesForBlog">Github</a>上（工程NSURLConnectionExample中的PTOperationDownloader）。</p>

<h3>参考资料</h3>

<p><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html">Concurrency Programming Guide</a></p>

<p><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSOperation_class/Reference/Reference.html">NSOperation Class Reference</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block的引用循环问题 (ARC & non-ARC)]]></title>
    <link href="http://hrchen.com/2013/06/retain-cycle-in-block/"/>
    <updated>2013-06-27T00:32:00+08:00</updated>
    <id>http://hrchen.com/2013/06/retain-cycle-in-block</id>
    <content type="html"><![CDATA[<p>2010年WWDC发布iOS4时Apple对Objective-C进行了一次重要的升级：支持Block。说到底这东西就是闭包，其他高级语音例如Java和C++已有支持，第一次使用Block感觉满简单好用的，但是慢慢也遇到很多坑。本文聊聊ARC和non-ARC下Block使用中的引用循环问题，最近遇到了好几次这种问题，还是深入记录下。先来套<a href="http://blog.parse.com/2013/02/05/objective-c-blocks-quiz/">题目</a>热热身，貌似能够全部答对的人蛮少的</p>

<h3>Block实现原理</h3>

<p>首先探究下Block的实现原理，由于Objective-C是C语言的超集，既然OC中的NSObject对象其实是由C语言的struct+isa指针实现的，那么Block的内部实现估计也一样，以下三篇Blog对Block的实现机制做了详细研究：</p>

<ul>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/">A look inside blocks: Episode 1</a></li>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/">A look inside blocks: Episode 2</a></li>
<li><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-3/">A look inside blocks: Episode 3</a></li>
</ul>


<p>虽然实现细节看着头痛，不过发现Block果然是和OC中的NSObject类似，也是用struct实现出来的东西。这个是LLVM项目compiler-rt分析的block头文<a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h">Block_private.h</a>头文件中关于Block的struct声明：</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct Block_descriptor {
</span><span class='line'>    unsigned long int reserved;
</span><span class='line'>    unsigned long int size;
</span><span class='line'>    void (*copy)(void *dst, void *src);
</span><span class='line'>    void (*dispose)(void *);
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>struct Block_layout {
</span><span class='line'>    void *isa;
</span><span class='line'>    int flags;
</span><span class='line'>    int reserved;
</span><span class='line'>    void (*invoke)(void *, ...);
</span><span class='line'>    struct Block_descriptor *descriptor;
</span><span class='line'>    /* Imported variables. */
</span><span class='line'>};
</span></code></pre></td></tr></table></div></figure>


<p>我们发现Block_layout中也有一个isa指针，像极了NSobject内部实现struct中的isa指针。这里的isa可能指向三种类型之一的Block：</p>

<ul>
<li>_NSConcreteGlobalBlock：全局类型Block，在编译器就已经确定，直接放在代码段__TEXT上。直接在NSLog中打印的类型为__NSGlobalBlock__。</li>
<li>_NSConcreteStackBlock：位于栈上分配的Block，即__NSStaclBlock__。</li>
<li>_NSConcreteMallocBlock：位于堆上分配的Block，即__NSMallocBlock__。</li>
</ul>


<p>为什么会有这么多种类呢？首先来看全局类型Block，看例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void addBlock(NSMutableArray *array) {
</span><span class='line'>  [array addObject:^{
</span><span class='line'>    printf("global block\n");
</span><span class='line'>  }];
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void example() {
</span><span class='line'>  NSMutableArray *array = [NSMutableArray array];
</span><span class='line'>  addBlock(array);
</span><span class='line'>  void (^block)() = [array objectAtIndex:0];
</span><span class='line'>  block();
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>为什么addBlock中添加到array中的Block属于全局Block呢？因为它不需要运行时(Runtime)任何的状态来改变行为，不需要放在堆上或者栈上，直接编译后在代码段中即可，就像个c函数一样。这种类型的Block在ARC和non-ARC情况下没有差别。</p>

<p>这个Block访问了作用域外的变量d，在实现上就是这个block会多一个成员变量对应这个d，在赋值<sup>block</sup>时会将方法exmpale中的d变量值复制到成员变量中，从而实现访问。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void example() {
</span><span class='line'>  int d = 5;
</span><span class='line'>  void (^block)() = ^() {
</span><span class='line'>      printf("%d\n", d);
</span><span class='line'>  };
</span><span class='line'>  block();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果要修改d呢？：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void example() {
</span><span class='line'>  int d = 5;
</span><span class='line'>  void (^block)() = ^() {
</span><span class='line'>      d++;
</span><span class='line'>      printf("%d\n", d);
</span><span class='line'>  };
</span><span class='line'>  block();
</span><span class='line'>  printf("%d\n", d);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>由于局部变量d和这个block的实现不在同一作用域，仅仅在调用过程中用到了值传递，所以不能直接修改，而需要加一个标识符<code>__block int d = 5;</code>，那么block就可以实现对这个局部变量的修改了。如果是这种<strong>block标识的变量，在Block实现中不再是简单的一个成员变量，而是对应一个新的结构体表示这个</strong>block变量。<strong>block的本质是引入了一个新的</strong>Block_byref<em>{$var_name}</em>{$index}结构体，被<strong>block关键字修饰的变量就被放到这个结构体中。另外，block结构体通过引入</strong>Block_byref<em>{$var_name}</em>{$index}指针类型的成员，得以间接访问到Block的外部变量。这样对Block外的变量访问从值传递转变为引用，从而有了修改内容的能力。</p>

<p>正常我们使用Block是在栈上生成的，离开了栈作用域便释放了，如果copy一个Block，那么会将这个Block copy到堆上分配，这样就不再受栈的限制，可以随意使用啦。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>typedef void (^TestBlock)();
</span><span class='line'> 
</span><span class='line'>TestBlock getBlock() {
</span><span class='line'>  char e = 'E';
</span><span class='line'>  void (^returnedBlock)() = ^{
</span><span class='line'>    printf("%c\n", e);
</span><span class='line'>  };
</span><span class='line'>  return returnedBlock;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void example() {
</span><span class='line'>  TestBlock block = getBlock();
</span><span class='line'>  block();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>函数getBlock中声明并赋值的returnedBlock，一开始是在栈上分配的，属于NSStackBlock，如果是non-ARC情况下return这个NSStackBlock，那么其实已经被销毁了，在函数中example()使用时就会crash。如果是ARC情况下，getBlock返回的block会自动copy到堆上，那么block的类型就是NSMallocBlock，可以在example()中继续使用。要在Non-ARC情况下正常运行，那么就应该修改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TestBlock getBlock() {
</span><span class='line'>  char e = 'E';
</span><span class='line'>  void (^returnedBlock)() = ^{
</span><span class='line'>    printf("%c\n", e);
</span><span class='line'>  };
</span><span class='line'>  return [[returnedBlock copy] autorelease];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Block中的循环引用问题</h3>

<p>扯了这么多，回到Block的循环引用问题，由于我们很多行为会导致Block的copy，而当Block被copy时，会对block中用到的对象产生强引用(ARC下)或者引用计数加一(non-ARC下)。</p>

<p>如果遇到这种情况：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(nonatomic, readwrite, copy) completionBlock completionBlock;
</span><span class='line'>
</span><span class='line'>//========================================
</span><span class='line'>self.completionBlock = ^ {
</span><span class='line'>        if (self.success) {
</span><span class='line'>            self.success(self.responseData);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>对象有一个Block属性，然而这个Block属性中又引用了对象的其他成员变量，那么就会对这个变量本身产生强应用，那么变量本身和他自己的Block属性就形成了循环引用。在ARC下需要修改成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(nonatomic, readwrite, copy) completionBlock completionBlock;
</span><span class='line'>
</span><span class='line'>//========================================
</span><span class='line'>__weak typeof(self) weakSelf = self;
</span><span class='line'>self.completionBlock = ^ {
</span><span class='line'>    if (weakSelf.success) {
</span><span class='line'>        weakSelf.success(weakSelf.responseData);
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>也就是生成一个对自身对象的弱引用，如果是倒霉催的项目还需要支持iOS4.3，就用__unsafe_unretained替代__weak。如果是non-ARC环境下就将__weak替换为__block即可。non-ARC情况下，__block变量的含义是在Block中引入一个新的结构体成员变量指向这个__block变量，那么<code>__block typeof(self) weakSelf = self;</code>就表示Block别再对self对象retain啦，这就打破了循环引用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个异步网络请求的坑：关于NSURLConnection和NSRunLoopCommonModes]]></title>
    <link href="http://hrchen.com/2013/06/nsurlconnection-with-nsrunloopcommonmodes/"/>
    <updated>2013-06-24T16:15:00+08:00</updated>
    <id>http://hrchen.com/2013/06/nsurlconnection-with-nsrunloopcommonmodes</id>
    <content type="html"><![CDATA[<p>我们开发App时，常常需要异步下载网络资源或者实现REST API调用，目前流行的HTTP库有<a href="https://github.com/pokeb/asi-http-request/">ASIHTTPRequest</a>（已经停止开发维护）和<a href="https://github.com/AFNetworking/AFNetworking">AFNetWorking</a>。两者实现异步网络请求的方式不太相同，ASIHTTPRequest使用的是NSOperation+CFNetWork API实现异步网络请求，但是在一个公共独立子线程上去执行网络请求：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSThread *)threadForRequest:(ASIHTTPRequest *)request
</span><span class='line'>{
</span><span class='line'>  if (networkThread == nil) {
</span><span class='line'>      @synchronized(self) {
</span><span class='line'>          if (networkThread == nil) {
</span><span class='line'>              networkThread = [[NSThread alloc] initWithTarget:self selector:@selector(runRequests) object:nil];
</span><span class='line'>              [networkThread start];
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  return networkThread;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>AFNetWorking则是包装了NSOperation和NSURLConnection技术实现异步网络请求，它在NSOperation中真正启动NSURLConnection网络请求时，同样生成了一个公共独立子线程来Kick off网络请求：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSThread *)networkRequestThread {
</span><span class='line'>    static NSThread *_networkRequestThread = nil;
</span><span class='line'>    static dispatch_once_t oncePredicate;
</span><span class='line'>    dispatch_once(&oncePredicate, ^{
</span><span class='line'>        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
</span><span class='line'>        [_networkRequestThread start];
</span><span class='line'>    });
</span><span class='line'>
</span><span class='line'>    return _networkRequestThread;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<!-- more -->


<p>ASIHTTPRequest和AFNetWorking实际上都是使用一个公共独立子线程配合Run Loop来实现管理网络请求
。由于我在开发中需要一个简单的网络图片下载功能，直接使用第三方库需要添加太多文件，就写了一个类似Sample Code中PTNormalDownloaler下载类，当时遇到个tricky的问题。</p>

<p>首先，如果是直接调用NSURLConnection的initWithRequest:delegate:startImmediately:（第三个参数用YES，这个是designated initializer）或者方法initWithRequest:delegate:时，NSURLConnection会默认运行在NSDefaultRunLoopMode模式下，即使再使用scheduleInRunLoop:forMode:设置运行模式也没有用。如果NSURLConnection运行在NSDefaultRunLoopMode下，何为Run Loop的模式Mode，请参考这篇<a href="http://www.hrchen.com/2013/06/multi-threading-programming-of-ios-part-1/">Blog</a>），
这篇Blog提到NSDefaultRunLoopMode是Run Loop默认的运行模式，用于处理除了NSConnection对象的事件。
然而如果NSURLConnection是运行在NSDefaultRunLoopMode，而当前线程是主线程，并且UI上有类似滚动这样的操作，那么主线程的Run Loop会运行在UITrackingRunLoopMode下，就无法响应NSURLConnnection的回调。此时需要首先使用initWithRequest:delegate:startImmediately:（第三个参数为NO）生成NSURLConnection，再重新设置NSURLConnection的运行模式为NSRunLoopCommonModes，那么UI操作和回调的执行都将是非阻塞的，因为NSRunLoopCommonModes是一组run loop mode的集合，默认情况下包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)start
</span><span class='line'>{
</span><span class='line'>    NSMutableURLRequest* request = [[NSMutableURLRequest alloc]   
</span><span class='line'>                initWithURL:self.URL
</span><span class='line'>                cachePolicy:NSURLCacheStorageNotAllowed
</span><span class='line'>                timeoutInterval:self.timeoutInterval];
</span><span class='line'>    [request setHTTPMethod: @"GET"];
</span><span class='line'>    self.connection =[[NSURLConnection alloc] initWithRequest:request
</span><span class='line'>                                                     delegate:self
</span><span class='line'>                                             startImmediately:NO];
</span><span class='line'>    [self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
</span><span class='line'>    [self.connection start];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>其次在调用PTNormalDownloaler的start方法时，如果是用GCD在其他线程中开始运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(){
</span><span class='line'>        [downloader start];
</span><span class='line'>    });
</span></code></pre></td></tr></table></div></figure>


<p>而非在主线程中运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[downloader performSelectorOnMainThread:@selector(start) 
</span><span class='line'>                             withObject:nil 
</span><span class='line'>                          waitUntilDone:YES];</span></code></pre></td></tr></table></div></figure>


<p>你在GCD的全局队列里运行的PTNormalDownloaler中的不会得到NSURLConnection回调，而从主线程中启动NSURLConnection可以得到回调，这是由于在GCD全局队列中执行时没有运行Run Loop，那么NSURLConnection也就无法触发回调了。</p>

<p>当然在GCD的全局队列里启动NSURLConnection需要这样这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(){
</span><span class='line'>        [downloader start];
</span><span class='line'>        NSLog(@"current worker thread: %@", [NSThread currentThread]);
</span><span class='line'>        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
</span><span class='line'>        NSLog(@"exit worker thread");
</span><span class='line'>    });
</span></code></pre></td></tr></table></div></figure>


<p>如果从主线程启动NSURLConntection，其回调会在主线程中被调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2013-06-26 19:35:13.309 NSURLConnectionExample[22646:50b] connectionDidFinishLoading in main thread?: 1</span></code></pre></td></tr></table></div></figure>


<p>如果是在子线程启动NSURLConntection，其回调则会在子线程中被调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2013-06-26 19:38:18.937 NSURLConnectionExample[22670:3903] connectionDidFinishLoading in main thread?: 0</span></code></pre></td></tr></table></div></figure>


<p>在主线程启动NSURLConnection会不会影响主线程的UI？影响肯定会有，但是网络IO本身不会影响，那是底层操作系统的事情，仅仅是网络IO结束后由主线程来处理回调而已。</p>

<p>样例程序里也实现了一个基于子线程的下载器PTThreadDownloader，与ASIHTTPRequest和AFNetWorking中的方法类似，生成一个公共子线程来启动NSURLConnection。这里没有必要对每个网络请求都生成一个后台子线程去启动NSURLConnection（例如上面那种用GCD扔到global queue的方式最终也是每次从线程池找到一个线程来启动NSURLConnection），因为底层网络IO并不是在这个子线程里去执行的，子线程仅仅用于响应NSURLConnection回调。不过公共子线程的方法会导致有一个子线程一直运行在后台，等待用户用它来启动NSURLConnection。</p>

<h3>Sample Code</h3>

<p>本文例子放在<a href="https://github.com/hrchen/ExamplesForBlog">Github</a>上（工程NSURLConnectionExample），可以根据文中的几种情况测试initWithRequest:delegate:startImmediately:第三个参数的影响以及回调问题，例子UI中的按钮每点击一次会产生一个下载PTNormalDownloaler对象并开始执行，如果这个NSURLConnection是运行在NSDefaultRunLoopMode模式下，那么上下滚动UI中的Table View，是不会触发NSURLConnection回调的，只有UI操作结束后才会触发。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程编程Part 1/3 - NSThread & Run Loop]]></title>
    <link href="http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-1/"/>
    <updated>2013-06-02T23:11:00+08:00</updated>
    <id>http://hrchen.com/2013/06/multi-threading-programming-of-ios-part-1</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>多线程的价值无需赘述，对于App性能和用户体验都有着至关重要的意义，在iOS开发中，Apple提供了不同的技术支持多线程编程，除了跨平台的pthread之外，还提供了NSThread、NSOperationQueue、GCD等多线程技术，从本篇Blog开始介绍这几种技术的细节。</p>

<p>对于pthread这种跨平台的多线程技术，这本<a href="http://www.amazon.com/Programming-POSIX-Threads-David-Butenhof/dp/0201633922/">Programming with POSIX Threads</a>做了详细介绍，不再提及。</p>

<h3>NSThread</h3>

<p>使用NSThead创建线程有很多方法：</p>

<ul>
<li>+detachNewThreadSelector:toTarget:withObject:类方法直接生成一个子线程</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">NSThread</span> <span class="nl">detachNewThreadSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">threadRoutine:</span><span class="p">)</span> <span class="nl">toTarget:</span><span class="n">self</span> <span class="nl">withObject:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>创建一个NSThread类实例，然后调用start方法。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSThread</span><span class="o">*</span> <span class="n">aThread</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">threadRoutine:</span><span class="p">)</span> <span class="nl">object:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">aThread</span> <span class="n">start</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>调用NSObject的<code>+performSelectorInBackground:withObject:</code>方法生成子线程。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">myObj</span> <span class="nl">performSelectorInBackground:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">threadRoutine:</span><span class="p">)</span> <span class="nl">withObject:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>创建一个NSThread子类，然后调用子类实例的start方法，。</li>
</ul>


<!-- more -->


<p>创建线程也是有开销的，iOS下主要成本包括构造内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1MB，不过可以使用方法<code>-setStackSize:</code>自己设置，注意必须是4K的倍数，而且最小是16K），创建线程大约需要90毫秒的创建时间。</p>

<p>第二种和第四种方法创建的线程有个好处是拥有线程的对象，因此可以使用<code>performSelector:onThread:withObject:waitUntilDone:</code>在该线程上执行方法，这是一种非常方便的线程间通讯的方法（相对于设置麻烦的NSPort用于通讯），所要执行的方法可以直接添加到目标线程的Runloop中执行。Apple建议使用这个接口运行的方法不要是耗时或者频繁的操作，以免子线程的负载过重。</p>

<p>第三种方法其实与第一种方法是一样的，都会直接生成一个子线程。</p>

<p>上面四种方法生成的子线程都是detached状态，即主线程结束时这些线程都会被直接杀死；如果要生成joinable状态的子线程，只能使用pthread接口啦。</p>

<p>如果需要，可以设置线程的优先级(<code>-setThreadPriority:</code>)；如果要在线程中保存一些状态信息，还可以使用到<code>-threadDictionary</code>得到一个NSMutableDictionary，以key-value的方式保存信息用于线程内读写。</p>

<h3>NSThread的入口方法</h3>

<p>要写一个有效的子线程入口方法需要注意很多问题，示例代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">threadRoutine</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSAutoreleasePool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kt">BOOL</span> <span class="n">moreWorkToDo</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">exitNow</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSRunLoop</span><span class="o">*</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSMutableDictionary</span><span class="o">*</span> <span class="n">threadDict</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSThread</span> <span class="n">currentThread</span><span class="p">]</span> <span class="n">threadDictionary</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">threadDict</span> <span class="nl">setValue:</span><span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithBool:</span><span class="n">exitNow</span><span class="p">]</span> <span class="nl">forKey:</span><span class="s">@&quot;ThreadShouldExitNow&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//添加事件源</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">myInstallCustomInputSource</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">moreWorkToDo</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">exitNow</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">//执行线程真正的工作方法，如果完成了可以设置moreWorkToDo为False</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="nl">runUntilDate:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">exitNow</span> <span class="o">=</span> <span class="p">[[</span><span class="n">threadDict</span> <span class="nl">valueForKey:</span><span class="s">@&quot;ThreadShouldExitNow&quot;</span><span class="p">]</span> <span class="n">boolValue</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">pool</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>必须创建一个NSAutoreleasePool，因为子线程不会自动创建。同时要注意这个pool因为是最外层pool，如果线程中要进行长时间的操作生成大量autoreleased的对象，则只有在该子线程退出时才会回收，因此如果线程中会大量创建autoreleased对象，那么需要创建额外的NSAutoreleasePool，可以在NSRunloop每次迭代时创建和销毁一个NSAutoreleasePool。</li>
<li>如果你的子线程会抛出异常，最好在子线程中设置一个异常处理函数，因为如果子线程无法处理抛出的异常，会导致程序直接Crash关闭。</li>
<li>(可选)设置Run Loop，如果子线程只是做个一次性的操作，那么无需设置Run Loop；如果子线程进入一个循环需要不断处理一些事件，那么设置一个Run Loop是最好的处理方式，如果需要Timer，那么Run Loop就是必须的。</li>
<li>如果需要在子线程运行的时候让子线程结束操作，子线程每次Run Loop迭代中检查相应的标志位来判断是否还需要继续执行，可以使用threadDictionary以及设置Input Source的方式来通知这个子线程。那么什么是Run Loop呢？这是涉及NSThread及线程相关的编程时无法回避的一个问题。</li>
</ul>


<h3>Run Loop</h3>

<p>Run Loop是个让人迷惑的概念，相关的介绍资料也很少，它的主要的特性如下：</p>

<ul>
<li>每个线程都有一个Run Loop，主线程的Run Loop会在App运行时自动运行，子线程中需要手动运行。</li>
<li>每个Run Loop都会以一个模式mode来运行，可以使用NSRunLoop的<code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate</code> 方法运行在某个特定模式mode。</li>
<li>Run Loop的处理两大类事件源：Timer Source和Input Source(包括performSelector***方法簇、Port或者自定义Input Source)，每个事件源都会绑定在Run Loop的某个特定模式mode上，而且只有RunLoop在这个模式运行的时候才会触发该Timer和Input Source。</li>
<li>如果没有任何事件源添加到Run Loop上，Run Loop就会立刻exit。</li>
</ul>


<p>Run Loop如何运行呢？在上一节NSThread的入口函数中已经说明了一种NSRunLoop的使用场景，再看一例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="err">@</span><span class="n">autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;starting thread.......&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSTimer</span> <span class="o">*</span><span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSTimer</span> <span class="nl">timerWithTimeInterval:</span><span class="mi">2</span> <span class="nl">target:</span><span class="n">self</span> <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doTimerTask</span><span class="p">)</span> <span class="nl">userInfo:</span><span class="nb">nil</span> <span class="nl">repeats:</span><span class="n">YES</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addTimer:</span><span class="n">timer</span> <span class="nl">forMode:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">timer</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="o">!</span> <span class="n">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="n">doOtherTask</span><span class="p">];</span>
</span><span class='line'>            <span class="kt">BOOL</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">runMode:</span><span class="n">NSDefaultRunLoopMode</span> <span class="nl">beforeDate:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">distantFuture</span><span class="p">]];</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;after runloop counting.........: %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;finishing thread.........&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doTimerTask</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;do timer task&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doOtherTask</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;do other task&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们看到入口方法里创建了一个NSTimer，并且以NSDefaultRunLoopMode模式加入到当前子线程的NSRunLoop中，正常情况肯定会执行<code>-doOtherTask</code>方式法一次，然后再以NSDefaultRunLoopMode模式运行NSRunLoop，如果一次Timer事件触发处理后，这个Run Loop会返回吗？答案是不会。NSRunLoop的底层实现是CFRunLoop，具体内部实现不透明，你可以想象成一个循环，当没有事件触发时，你调用Run Loop的运行方法不会返回继续监听其他事件源，Run Loop会让子线程进入sleep等待状态而不是空转，只有当Timer Source或者Input Source事件发生时，子线程才会被唤醒，处理触发的事件，不过由于Timer source比较特殊，Timer Source事件发生处理后，<code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code>方法不会返回；而其他非Timer事件的触发处理会让这个Run Loop退出并返回YES。</p>

<p>当你将子线程的Run Loop运行在一个特定模式时，如果该模式下没有事件源，运行Run Loop也会立刻返回NO。如果你添加一个Input Source，例如<code>[[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</code>或者持有子线程的对象在这个子线程上运行方法，例如<code>[self performSelector:@selector(doThreadTask) onThread:thread withObject:nil waitUntilDone:NO];</code>就会让这个Run Loop进入等待状态，即<code>-runMode:BeforDate</code>处于阻塞状态不返回。</p>

<h3>Run Loop的事件源</h3>

<p>归根结底，Run Loop就是个处理事件的Loop，可以让你添加Timer和其他Input Source等各种事件源，如果事件源没有发生时，Run Loop就会让线程进入asleep状态，而事件源发生时就会唤醒休眠的(asleep)的子线程来处理事件。Run Loop的事件源事件源分两类：Timer Source和Input Source(包括-performSelector:***API调用簇，Port Input Source、自定义Input Source)。</p>

<p><img src="http://hrchen.com/images/post/runloop_source.jpg"></p>

<p>从上图可以看出Run Loop就是处理事件的一个循环，不同的是Timer Source事件处理后不会使Run Loop结束，而Input Source事件处理后会让Run Loop退出。因此你需要自己的一个Loop去不断运行Run Loop来处理事件，就像本文开头的示例那样。</p>

<p>细分下Run Loop的事件源：</p>

<p>1) Timer Souce就是创建Timer添加到Run Loop中，没啥好说的，Cocoa或者Core Foundation都有相应接口实现。需要注意的是<code>scheduledTimerWith****</code>开头生成的Timer会自动帮你加载到当前的Run Loop中，而其他接口生成的Timer则需要你手动使用<code>-addTimer:forMode</code>添加到Run Loop中。需要额外注意的是Timer的触发不会让Run Loop返回。(Timer sources deliver events to their handler routines but do not cause the run loop to exit.) 具体实验可以看下面的Sample Code。</p>

<p>2) Input Source中的-performSelector:***API调用簇方法，有以下这些接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="nl">performSelectorOnMainThread:withObject:waitUntilDone:</span>
</span><span class='line'><span class="nl">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span>
</span><span class='line'>
</span><span class='line'><span class="nl">performSelector:onThread:withObject:waitUntilDone:</span>
</span><span class='line'><span class="nl">performSelector:onThread:withObject:waitUntilDone:modes:</span>
</span><span class='line'>
</span><span class='line'><span class="nl">performSelector:withObject:afterDelay:</span>
</span><span class='line'><span class="nl">performSelector:withObject:afterDelay:inModes:</span>
</span><span class='line'>
</span><span class='line'><span class="nl">cancelPreviousPerformRequestsWithTarget:</span>
</span><span class='line'><span class="nl">cancelPreviousPerformRequestsWithTarget:selector:object:</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些API最后两个是取消当前线程中调用，其他API是在主线程或者当前线程下的Run Loop中执行指定的@selector。</p>

<p>3) Port Input Source：概念上也比较简单，可以用NSMachPort作为线程之间的通讯通道。例如在主线程创建子线程时传入一个NSPort对象，这样主线程就可以和这个子线程通讯啦，如果要实现双向通讯，那么子线程也需要回传给主线程一个NSPort。</p>

<p>NSPort的子类除了NSMachPort，还可以使用NSMessagePort或者Core Foundation中的CFMessagePortRef。</p>

<h4>注意：虽然有这么棒的方式实现线程间通讯方式，但是估计是由于危及iOS的Sandbox沙盒环境，所以这些API都是私有接口，如果你用到NSPortMessage，XCode会提示<code>'NSPortMessage' for instance message is a forward declaration</code>。</h4>

<p>4) 自定义Input Source：</p>

<p>向Run Loop添加自定义Input Source只能使用Core Foundation的接口：<code>CFRunLoopSourceCreate</code>创建一个source，<code>CFRunLoopAddSource</code>向Run Loop中添加source，<code>CFRunLoopRemoveSource</code>从Run Loop中删除source，<code>CFRunLoopSourceSignal</code>通知source，<code>CFRunLoopWakeUp</code>唤醒Run Loop。</p>

<p>Apple官方文档提供了一个自定义Input Source使用模式。</p>

<p><img src="http://hrchen.com/images/post/input_source.jpg"></p>

<p>主线程持有包含子线程的Run Loop和Source的context对象，还有一个用于保存需要运行操作的数据buffer。主线程需要子线程干活时，首先将需要的操作数据添加到数据buffer，然后通知source，唤醒子线程Run Loop（因为子线程可能正在sleep状态，<code>CFRunLoopWakeUp</code>唤醒Run Loop可以通知线程醒来干活），由于子线程也持有这个source和数据buffer，因此在触发唤醒时可以使用这个数据buffer的数据来执行相关操作（需要注意数据buffer访问时的同步）。</p>

<p>具体实现参见本文最后的Sample Code。</p>

<h3>Run Loop的运行</h3>

<p>之前说的Run Loop的运行方式感觉有点绕，容易晕，而且《Threading Programming Guide》可能是最初Mac下的Run Loop，iOS下情况有一些不一样。在此总结NSRunLoop的三个运行接口：</p>

<ul>
<li><code>- (void)run;</code> 无条件运行</li>
</ul>


<p>不建议使用，因为这个接口会导致Run Loop永久性的运行在NSDefaultRunLoopMode模式，即使使用<code>CFRunLoopStop(CFRunLoopGetCurrent());</code>也无法停止Run Loop的运行，那么这个子线程就无法停止，只能永久运行下去。</p>

<ul>
<li><code>- (void)runUntilDate:(NSDate *)limitDate;</code> 有一个超时时间限制</li>
</ul>


<p>比上面的接口好点，有个超时时间，可以控制每次Run Loop的运行时间，也是运行在NSDefaultRunLoopMode模式。这个方法运行Run Loop一段时间会退出给你检查运行条件的机会，如果需要可以再次运行Run Loop。注意<code>CFRunLoopStop(CFRunLoopGetCurrent());</code>也无法停止Run Loop的运行，因此最好自己设置一个合理的Run Loop运行时间。示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Done</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">runUntilDate:</span><span class="p">[</span><span class="n">NSDate</span> <span class="nl">dateWithTimeIntervalSinceNow:</span><span class="mi">10</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;exiting runloop.........:&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</code> 有一个超时时间限制，而且设置运行模式</li>
</ul>


<p>这个接口在非Timer事件触发、显式的用CFRunLoopStop停止Run Loop、到达limitDate后会退出返回。如果仅是Timer事件触发并不会让Run Loop退出返回；如果是PerfromSelector***事件或者其他Input Source事件触发处理后，Run Loop会退出返回YES。示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Done</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">runMode:</span><span class="n">NSDefaultRunLoopMode</span>
</span><span class='line'>                                      <span class="nl">beforeDate:</span><span class="p">[</span><span class="n">NSDate</span> <span class="n">distantFuture</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;exiting runloop.........: %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么如何知道一个Run Loop是因为什么原因exit返回的呢？NSRunLoop没有接口可以知道，而需要通过Core Foundation的接口来运行CFRunLoopRef，NSRunLoop其实就是CFRunLoopRef的二次封装。使用CFRunLoop的接口(C的接口)来运行Run Loop，有两个接口：</p>

<ul>
<li><code>void CFRunLoopRun(void);</code></li>
</ul>


<p>运行在默认的kCFRunLoopDefaultMode模式下，直到使用CFRunLoopStop接口停止这个Run Loop，或者Run Loop的所有事件源都被删除。</p>

<ul>
<li><code>SInt32 CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled);</code></li>
</ul>


<p>第一个参数是指RunLoop运行的模式（例如kCFRunLoopDefaultMode或者kCFRunLoopCommonModes），第二个参数是运行时间，第三个参数是是否在处理事件后让Run Loop退出返回。 示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">doOtherTask</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">SInt32</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CFRunLoopRunInMode</span><span class="p">(</span><span class="n">kCFRunLoopDefaultMode</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">YES</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">kCFRunLoopRunStopped</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">cancel</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;exit run loop.........: %ld&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果Run Loop退出返回后，返回值是SInt32类型，就是个signed long，表明Run Loop返回的原因，目前有四种：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">enum</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">kCFRunLoopRunFinished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">//Run Loop结束，没有Timer或者其他Input Source</span>
</span><span class='line'>    <span class="n">kCFRunLoopRunStopped</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">//Run Loop被停止，使用CFRunLoopStop停止Run Loop</span>
</span><span class='line'>    <span class="n">kCFRunLoopRunTimedOut</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">//Run Loop超时</span>
</span><span class='line'>    <span class="n">kCFRunLoopRunHandledSource</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1">////Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：Run Loop是可以递归调用的，例如一个Run Loop运行过程中一个事件触发后，那么在触发方法里可以再运行当前子线程的Run Loop，然后由这个Run Loop等待其他事件触发。不过这种Run Loop调用方式我用的比较少。</p>

<p>以上Run Loop运行方法参考本文最后的Sample Code自行尝试。</p>

<h3>Run Loop的运行模式Mode</h3>

<p>iOS下Run Loop的主要运行模式mode有：</p>

<p>1) NSDefaultRunLoopMode: 默认的运行模式，除了NSConnection对象的事件。</p>

<p>This is a configurable group of commonly used modes. Associating an input source with this mode also associates it with each of the modes in the group.</p>

<p>2) NSRunLoopCommonModes: 是一组常用的模式集合，将一个input source关联到这个模式集合上，等于将input source关联到这个模式集合中的所有模式上。例如在Mac下还有NSConnectionReplyMode、NSModalPanelRunLoopMode、NSEventTrackingRunLoopMode这些模式，我有个timer要关联到这些模式上，一个个注册很麻烦，我可以用<code>CFRunLoopAddCommonMode([[NSRunLoop currentRunLoop] getCFRunLoop],(__bridge CFStringRef) NSEventTrackingRunLoopMode)</code>将NSEventTrackingRunLoopMode或者其他模式添加到这个NSRunLoopCommonModes模式中，然后只需要将Timer关联到NSRunLoopCommonModes，即可以实现Run Loop运行在这个模式集合中任何一个模式时，这个Timer都可以被触发。默认情况下NSRunLoopCommonModes包含了NSDefaultRunLoopMode和UITrackingRunLoopMode。注意：让Run Loop运行在NSRunLoopCommonModes下是没有意义的，因为一个时刻Run Loop只能运行在一个特定模式下，而不可能是个模式集合。</p>

<p>3) UITrackingRunLoopMode: 用于跟踪触摸事件触发的模式（例如UIScrollView上下滚动），主线程当触摸事件触发时会设置为这个模式，可以用来在控件事件触发过程中设置Timer。</p>

<p>4) 自定义Mode：可以设置自定义的运行模式Mode，你也可以用CFRunLoopAddCommonMode添加到NSRunLoopCommonModes中。</p>

<h3>Run Loop的Observer</h3>

<p>可以定义一个Run Loop的观察者在Run Loop进入以下某个状态时得到通知：</p>

<ul>
<li>Run loop的进入</li>
<li>Run loop处理一个Timer的时刻</li>
<li>Run loop处理一个Input Source的时刻</li>
<li>Run loop进入睡眠的时刻</li>
<li>Run loop被唤醒的时刻，但在唤醒它的事件被处理之前</li>
<li>Run loop的终止</li>
</ul>


<p>Observer的创建以及添加到Run Loop中需要使用Core Foundation的接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopObserverContext</span>  <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">self</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">CFRunLoopObserverCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeTimers</span><span class="p">,</span> <span class="n">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myRunLoopObserver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">observer</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">kCFRunLoopCommonModes</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先创建Observer的context，然后调用Core Foundation方法CFRunLoopObserverCreate创建Observer，再加入到当前线程的Run Loop中，注意CFRunLoopObserverCreate方法的第二个参数是Observer观察类型，有如下几种：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/* Run Loop Observer Activities */</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">CF_OPTIONS</span><span class="p">(</span><span class="n">CFOptionFlags</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">kCFRunLoopEntry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCFRunLoopBeforeTimers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCFRunLoopBeforeSources</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCFRunLoopBeforeWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCFRunLoopAfterWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCFRunLoopExit</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCFRunLoopAllActivities</span> <span class="o">=</span> <span class="mh">0x0FFFFFFF</span><span class="n">U</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应Run Loop的各种事件，kCFRunLoopAllActivities比较特殊，可以观察所有事件。具体样例代码请参考Sample Code。</p>

<h3>总结</h3>

<p>Run Loop就是一个处理事件源的循环，你可以控制这个Run Loop运行多久，如果当前没有事件发生，Run Loop会让这个线程进入睡眠状态(避免再浪费CPU时间)，如果有事件发生，Run Loop就处理这个事件。Run Loop处理事件和发送给Observer通知的流程如下：</p>

<ul>
<li>1) 进入Run Loop运行，此时会通知观察者进入Run Loop；</li>
<li>2) 如果有Timer即将触发时，通知观察者；</li>
<li>3) 如果有非Port的Input Sourc即将e触发时，通知观察者；</li>
<li>4）触发非Port的Input Source事件源；</li>
<li>5）如果基于Port的Input Source事件源即将触发时，立即处理该事件，跳转到步骤9；</li>
<li>6）通知观察者当前线程将进入休眠状态；</li>
<li>7）将线程进入休眠状态直到有以下事件发生：基于Port的Input Source被触发、Timer被触发、Run Loop运行时间到了过期时间、Run Loop被唤醒。</li>
<li>8) 通知观察者线程将要被唤醒。</li>
<li>9) 处理被触发的事件：

<ul>
<li> 如果是用户自定义的Timer，处理Timer事件后重新启动Run Loop进入步骤2；</li>
<li> 如果线程被唤醒又没有到过期时间，则进入步骤2；</li>
<li> 如果是其他Input Source事件源有事件发生，直接处理这个事件；</li>
</ul>
</li>
<li>10)到达此步骤说明Run Loop运行时间到期，或者是非Timer的Input Source事件被处理后，Run Loop将要退出，退出前通知观察者线程已退出。</li>
</ul>


<p>什么时候需要用到Run Loop？官方文档的建议是：</p>

<ul>
<li>需要使用Port或者自定义Input Source与其他线程进行通讯。</li>
<li>需要在线程中使用Timer。</li>
<li>需要在线程上使用performSelector*****方法。</li>
<li>需要让线程执行周期性的工作。</li>
</ul>


<p>我个人在开发中遇到的需要使用Run Loop的情况有：</p>

<ul>
<li>使用自定义Input Source和其他线程通信</li>
<li>子线程中使用了定时器</li>
<li>使用任何performSelector*****到子线程中运行方法</li>
<li>使用子线程去执行周期性任务</li>
<li>NSURLConnection在子线程中发起异步请求</li>
</ul>


<h3>Sample Code</h3>

<p>RunLoop刚开始用确实坑很多，理解概念最好的方式还是动手写代码，写了个例子放在<a href="https://github.com/hrchen/ExamplesForBlog">GitHub</a>上（工程NSThreadExample），欢迎大家讨论。</p>

<p>Apple官方也有一个基于Run Loop的异步网络请求示例程序<a href="http://developer.apple.com/library/ios/#samplecode/SimpleURLConnections/Listings/Read_Me_About_SimpleURLConnections_txt.html">SimpleURLConnections</a>。</p>

<h3>参考资料</h3>

<p><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html">Threading Programming Guide</a></p>

<p><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/Reference/Reference.html">NSRunLoop Class Reference</a></p>

<p><a href="https://developer.apple.com/library/mac/#documentation/CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html">CFRunLoop Reference</a></p>

<p><a href="http://developer.apple.com/library/mac/#documentation/CoreFoundation/Reference/CFRunLoopObserverRef/Reference/reference.html">CFRunLoopObserver Reference</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App性能优化]]></title>
    <link href="http://hrchen.com/2013/05/performance-with-instruments/"/>
    <updated>2013-05-29T14:20:00+08:00</updated>
    <id>http://hrchen.com/2013/05/performance-with-instruments</id>
    <content type="html"><![CDATA[<h3>iOS App的性能关注点</h3>

<p>虽然iPhone的机能越来越好，但是app的功能也越来越复杂，性能从来都是移动开发的核心关注点之一。我们说一个app性能好，不是简单指感觉运行速度快，而应该是指应用启动快速、UI反馈响应及时、列表滚动操作流畅、内存使用合理，当然更不能随随便便Crash啦。工程师开发应用时除了在设计上要避免性能“坑”的出现，在实际遇到“坑”时也要能很快定位原因所在。定位性能问题原因当然不能靠猜，合理的方法是使用工具测量评估出投资回报最高的问题点，然后再加以优化。</p>

<p>本文会从以下几点介绍如何分析和优化iOS app的性能：启动时间、用户响应、内存、图形动画、文件和网络I/O。其中会用到Apple出品的性能分析神器“Instruments”。</p>

<h3>启动时间</h3>

<p>应用启动时间长短对用户第一次体验至关重要，同时系统对应用的启动、恢复等状态的运行时间也有严格的要求，在应用超时的情况下系统会直接关闭应用。以下是几个常见场景下系统对app运行时间的要求：
* Launch    20秒<em> Resume   10秒</em> Suspend  10秒<em> Quit 6秒</em> Background Task   10分钟</p>

<!-- more -->


<p>要获取准确的app启动所需时间，最简单的方法时首先在main.c中添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFAbsoluteTime</span> <span class="n">StartTime</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">StartTime</span> <span class="o">=</span> <span class="n">CFAbsoluteTimeGetCurrent</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在AppDelegate的回调方法<code>application:didFinishLaunchingWithOptions</code>中添加：</p>

<pre><code>dispatch_async(dispatch_get_main_queue(), ^{
    NSLog(@”Lauched in %f seconds.”,  (CFAbsoluteTimeGetCurrent() – StartTime)); 
});可能你会觉得为什么这样可拿到系统启动的时间，因为这个dispatch_async中提交的工作会在app主线程启动后的下一个run lopp中运行，此时app已经完成了载入并且将要显示第一帧画面，也就是系统会运行到`-[UIApplication _reportAppLaunchFinished]`之前。下图是用Instruments工具Time Profiler跑的调用栈，Instruments的使用方法建议看WWDC中与performance相关的[session录像](https://developer.apple.com/videos/wwdc)，文字写起来太单薄不够直观哈。
</code></pre>

<p><img src="http://hrchen.com/images/post/loading_app.png"></p>

<p>从图中我们可以看到在系统调用<code>[UIApplication _reportAppLaunchFinished]</code>之前完成了系统回调<code>application:didFinishLaunchingWithOptions</code>。</p>

<p>App的启动会包括以下几个部分（来自<a href="https://developer.apple.com/videos/wwdc/2012/">WWDC 2012 Session 235</a>）:</p>

<p>1）链接和载入：可以在Time Profile中显示dyld载入库函数，库会被映射到地址空间，同时完成绑定以及静态初始化。</p>

<p>2）UIKit初始化：如果应用的Root View Controller是由XIB实现的，也会在启动时被初始化。</p>

<p>3）应用回调：调用UIApplicationDeleagte的回调：<code>application:didFinishLaunchingWithOptions</code></p>

<p>4）第一次Core Animation调用：在启动后的方法<code>-[UIApplication _resportAppLaunchFinished]</code>中调用<code>CA::Transaction::commit</code>实现第一帧画面的绘制。如果你的程序启动很慢，能     做的首先是将与显示第一屏画面无关的操作放到之后执行；如果是用XIB文件load第一屏，XIB文件中的View层也要如果扁平，不要有太多图层。</p>

<h3>用户响应</h3>

<p>如何能够让用户觉得你的app响应迅速呢？当然是app用户所触发的操作都能得到立刻响应，即用户事件(User Event)能够被主线程的run loop及时处理。什么是run loop？可以想象成一个处理事件的select多路复用。主线程中的run loop当然主要是为了处理用户产生的事件啦，例如点击、滚动等。以后我们会详细聊聊run loop这个让人迷惑的东东。</p>

<p>要让主线程的run loop更好的响应用户事件，工程师应该尽量减少主线程干重活的时间，尤其是读文件啊，网络操作啊，大量运算啊这类重活，如果是阻塞操作，那就更是大忌了。我们可以用多线程(NSThread、NSOperationQueue, GCD，下一篇Blog就会聊到这多线程)将重活移出主线程，这属于显式并发。还有种隐式并发，例如view和layer的动画、layer的绘制以及PNG图片的解码都是在另一个子线程中执行的。除了使用多线程技术减轻主线程的负担外，减少主线程中阻塞也是提升用户体验的一个方法。使用Instruments中Time Profiler工具中的&#8221;Recod thread waiting&#8221;选项可以统计出app运行时各个线程中的阻塞系统调用情况，例如文件读写read/write，网络读写send/recv，加锁psynch_mutex_wait等。Instruments中的System Trace工具则能够记录所有的底层系统调用。</p>

<p><img src="http://hrchen.com/images/post/record_thread_waiting.png"></p>

<h3>内存</h3>

<p>内存问题从来都是iOS app的老大难问题，搞不好程序就爆了。由于iOS系统没有Swap文件(知道为啥不？留给悬念)，在内存不足时会将只读数据(例如code page)从内存中移出，需要的时候再从disk上读如内存；可读写数据不会被系统从内存中移出，然而如果占用的内存达到一个阈值，系统会发出相应的通知和回调让应用release对象以回收内存，如果仍然不能减少内存使用量，系统会直接关闭应用。尤其是iOS 5.0之后，如果你的app收到了memory warning，那么脑袋也是和其他app一样放在了案板上，随时有可能被kill掉，并不是说一定会先Kill掉在后台的app。</p>

<p>App使用的内存除了我们在堆上分配的内存外（<code>+[NSobject alloc]/malloc</code>），还会有更多使用内存的地方，比如代码和全局数据（<strong>TEXT和</strong>DATA），线程栈，图片，view 的layer backing store等等。因此处理内存问题，绝不仅仅是我们开发app时尽量少申请内存那么简单。</p>

<p>现在有了超炫的ARC，内存问题相对少了很多，开发效率也得到了提高。但是很多公司的项目仍然由于历史原因采用了手动管理内存，该做的活还是少不了。Xcode自带的静态分析功能可以帮你提前发现一些问题，然而有些内存问题是无法用静态分析来发现的，例如我们不断使用内存没有及时释放的问题，就无法使用静态分析器分析出来。此时可以使用Instruments的Allocations和Leaks工具来检查运行时的的内存使用以及泄露问题。</p>

<p><img src="http://hrchen.com/images/post/allocations.png"></p>

<p>Allocations工具可以很直观的反应app的内存使用情况，还有个很赞“Mark Heap”功能，在上图左边下半部分中的Heapshot Analysis中。例如你在进入一个页面前点击一下“Mark Heap”，然后再退回上一页面点击一下“Mark Heap”，如果你在进出这个页面里所申请的内存都得到了合理的释放，那么堆的内存增长量就应该降至0（见上图右下部分）。</p>

<p>另一种严重的内存使用问题是引用了已经释放的内存，直接导致应用崩溃，而Allocation有一个选项Enable NSZombie detection能够在应用使用已经释放的内存时标注出来，同时显示错误发生的调用栈信息。这为解决问题提供了最直接的帮助，当然缺点是必须能够重现EXEC_BAD_ACCESS错误。</p>

<p><img src="http://hrchen.com/images/post/zombies.png"></p>

<p>工具Leaks可以在应用运行时直接标示出存在内存泄露的代码，如果发生了内存泄露，可以从泄露详细信息中查看泄露的具体对象以及方法调用栈，大部分问题还是很好解决的。</p>

<p><img src="http://hrchen.com/images/post/leak.png"></p>

<h3>图形和动画</h3>

<p>图形性能对用户体验有直接的影响，Instruments中的Core Animation工具用于测量物理机上的图形性能，通过视图的刷新频率大小来判断应用的图形性能。例如一个复杂的列表滚动时它的刷新率应该努力趋近于60fps才能让用户觉得够流畅，从这个数字也可以算出run loop最长的响应时间应该是16毫秒。</p>

<p>启动Instruments的Core Animation工具后可以发现左下部分有一堆选项，我们来逐个介绍：</p>

<p><img src="http://hrchen.com/images/post/core_animation.png"></p>

<p>1) Color Blended Layers</p>

<p>Instruments可以在物理机上显示出被混合的图层Blended Layer(用红色标注)，Blended Layer是因为这些Layer是透明的(Transparent)，系统在渲染这些view时需要将该view和下层view混合(Blend)后才能计算出该像素点的实际颜色，如果这种blended layer很多，那么在滚动列表时就甭想有流畅的效果。</p>

<p><img src="http://hrchen.com/images/post/color_blended_layer.png"></p>

<p>解决blended layer问题也很简单，检查红色区域view的opaque属性，记得设置成YES；检查backgroundColor属性是不是<code>[UIColor clearColor]</code>，要知道背景颜色为clear color那可是图形性能的大敌，基本意味着blended layer是跑不了的了，为什么？自己思考一下:)</p>

<p>2) Color Hits Green and Misses Red</p>

<p>很多视图Layer由于Shadow、Mask和Gradient等原因渲染很高，因此UIKit提供了API用于缓存这些Layer：[layer setShouldRasterize:YES]，系统会将这些Layer缓存成Bitmap位图供渲染使用，如果失效时便丢弃这些Bitmap重新生成。图层Rasterization栅格化好处是对刷新率影响较小，坏处是删格化处理后的Bitmap缓存需要占用内存，而且当图层需要缩放时，要对删格化后的Bitmap做额外计算。
使用这个选项后时，如果Rasterized的Layer失效，便会标注为红色，如果有效标注为绿色。当测试的应用频繁闪现出红色标注图层时，表明对图层做的Rasterization作用不大。</p>

<p>3) Color Misaligned Images</p>

<p>Misaligned Image表示要绘制的点无法直接映射到频幕上的像素点，此时系统需要对相邻的像素点做anti-aliasing反锯齿计算，增加了图形负担，通常这种问题出在对某些View的Frame重新计算和设置时产生的。</p>

<p><img src="http://hrchen.com/images/post/color_misaligned_image.png"></p>

<p>上图中被标注为黄色的图层，这是由于图层显示的是被缩放后的图片，如果这些图片是通过网络下载的，可以通过程序更新为确定的绘制大小来解决。还有些系统Navigation Bar和Tool Bar的背景图片使用的是拉伸(Streched)图片，也会被表示为黄色，这是属于正常情况，通常无需修改。这种问题一般对性能影响不大，而是可能会在边缘处虚化。</p>

<p>(4) Color Offscreen-Rendered Yellow</p>

<p>Offscreen-Rendering离屏渲染意思是iOS要显示一个视图时，需要先在后台用CPU计算出视图的Bitmap，再交给GPU做Onscreen-Rendering显示在屏幕上，因为显示一个视图需要两次计算，所以这种Offscreen-Rendering会导致app的图形性能下降。</p>

<p>大部分Offscreen-Rendering都是和视图Layer的Shadow和Mask相关，下列情况会导致视图的Offscreen-Rendering：
1. 使用Core Graphics (CG开头的类)。
2.  使用drawRect()方法，即使为空。
3.  将CALayer的属性shouldRasterize设置为YES。
4.  使用了CALayer的setMasksToBounds(masks)和setShadow*(shadow)方法。
5.  在屏幕上直接显示文字，包括Core Text。
6.  设置UIViewGroupOpacity。</p>

<p>这篇博文<a href="http://robots.thoughtbot.com/post/36591648724/designing-for-ios-graphics-performance">Designing for iOS: Graphics &amp; Performance</a>对offsreen以及图形性能有个很棒的介绍，(5) Color Copied Images
Copied Image选项可以标注应用绘制时被Core Animation复制的图片，标注成蓝绿色。虽然我在运行时遇到过，不过个人感觉对图形性能影响不大。
(6) Color Immediately，Flash Updated Regions， Color OpenGL Fast Path Blue
Color Immediately选项表示Instruments在做color-flush操作时取消10毫秒的延时。Flash Updated Regions选项用于用红色示标示出在屏幕上使用GPU计算绘制的图层。Color OpenGL Fast Path Blue选项用于用蓝色标示出在屏幕上由OpenGL compositor绘制的内容。
这三个选项对图形性能的分析意义较小，通常仅作为参考。</p>

<h3>文件和网络I/O</h3>

<p>如果需要对app的文件和网络I/O情况做分析，可以用到这三个Instruments工具System Usage、File Activity和Network。</p>

<p>工具System Usage可以统计出运行状态下应用的文件和网络IO操作数据。例如我们发现应用启动后又一个峰值，这可能存在问题，我们可以利用System Usage工具的详细信息栏查看应用是由于对哪些文件的读写操作导致了峰值。</p>

<p>工具File Activity只能在模拟器中运行，因此数据采集可能不是非常准确。它同样可以详细给出读取的文件属性、大小、载入时间等信息，适合与System Usage配合使用。</p>

<p><img src="http://hrchen.com/images/post/file_activity.png"></p>

<p>Network工具则可以采集到应用的TCP/IP和UDP的使用信息(传输的数据量、当前所有TCP连接等)，用得不多，做网络使用状况分析时用用还行。</p>

<p><img src="http://hrchen.com/images/post/instruments_networking.png"></p>

<h3>更多阅读</h3>

<p>涉及iOS App性能的知识很多，上面只是冰山一角，重点推荐WWDC的session。</p>

<p>WWDC 2012:</p>

<ul>
<li>406: Adopting Automatic Reference Counting</li>
<li>238: iOS App Performance: Graphics and Animations</li>
<li>242: iOS App Performance: Memory</li>
<li>235: iOS App Performance: Responsiveness</li>
<li>409: Learning Instruments</li>
<li>706: Networking Best Practices</li>
<li>514: OpenGL ES Tools and Techniques</li>
<li>506: Optimizing 2D Graphics and Animation Performance</li>
<li>601: Optimizing Web Content in UIWebViews and Websites on iOS</li>
<li>225: Up and Running: Making a Great Impression with Every Launch</li>
</ul>


<p>WWDC 2011:</p>

<ul>
<li>105: Polishing Your App: Tips and tricks to improve the responsiveness and performance</li>
<li>121: Understanding UIKit Rendering</li>
<li>131 performance optimization on iphone os</li>
<li>308: Blocks and Grand Central Dispatch in Practice</li>
<li>323: Introducing Automatic Reference Counting</li>
<li>312: iOS Performance and Power Optimization with Instruments</li>
</ul>


<p>还有几篇不错的blog：</p>

<p>http://oleb.net/blog/2011/11/ios5-tech-talk-michael-jurewitz-on-performance-measurement/</p>

<p>http://eng.pulse.me/tips-for-improving-performance-of-your-ios-application/</p>

<p>http://robots.thoughtbot.com/post/36591648724/designing-for-ios-graphics-performance</p>

<p>http://www.touchwonders.com/en/how-to-make-your-apps-feel-responsive-and-fast-part-2/</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新开始写Blog]]></title>
    <link href="http://hrchen.com/2013/05/my-first-blog/"/>
    <updated>2013-05-26T22:27:00+08:00</updated>
    <id>http://hrchen.com/2013/05/my-first-blog</id>
    <content type="html"><![CDATA[<p>最近好几次被问到有没有个人Blog，惭愧=。=~~~~虽然曾经搭过WordPress、注册过Blogger，都没能坚持下来，其实写Blog对技术人员来说是很好的总结方式，值得坚持。</p>

<p>既然要整blog，当然要用正夯的工具，目前最方便的就是github pages啦，搭个<a href="https://github.com/imathis/octopress">octopress</a>，找个漂亮<a href="https://github.com/shashankmehta/greyshade">主题</a>，直接上！发现markdown写起来蛮像读书时写论文用的<a href="http://www.latex-project.org/">LaTex</a>，可以让你专注于码字，而不是格式。</p>
]]></content>
  </entry>
  
</feed>
